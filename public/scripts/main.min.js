(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*globals define, module, Symbol */
/*jshint -W056 */

(function (globals) {
  'use strict';

  var strings, messages, predicates, functions,
      assert, not, maybe, collections, slice;

  strings = {
    v: 'value',
    n: 'number',
    s: 'string',
    b: 'boolean',
    o: 'object',
    t: 'type',
    a: 'array',
    al: 'array-like',
    i: 'iterable',
    d: 'date',
    f: 'function',
    l: 'length'
  };

  messages = {};
  predicates = {};

  [
    { n: 'equal', f: equal, s: 'v' },
    { n: 'undefined', f: isUndefined, s: 'v' },
    { n: 'null', f: isNull, s: 'v' },
    { n: 'assigned', f: assigned, s: 'v' },
    { n: 'includes', f: includes, s: 'v' },
    { n: 'zero', f: zero },
    { n: 'infinity', f: infinity },
    { n: 'number', f: number },
    { n: 'integer', f: integer },
    { n: 'even', f: even },
    { n: 'odd', f: odd },
    { n: 'greater', f: greater },
    { n: 'less', f: less },
    { n: 'between', f: between },
    { n: 'greaterOrEqual', f: greaterOrEqual },
    { n: 'lessOrEqual', f: lessOrEqual },
    { n: 'inRange', f: inRange },
    { n: 'positive', f: positive },
    { n: 'negative', f: negative },
    { n: 'string', f: string, s: 's' },
    { n: 'emptyString', f: emptyString, s: 's' },
    { n: 'nonEmptyString', f: nonEmptyString, s: 's' },
    { n: 'contains', f: contains, s: 's' },
    { n: 'match', f: match, s: 's' },
    { n: 'boolean', f: boolean, s: 'b' },
    { n: 'object', f: object, s: 'o' },
    { n: 'emptyObject', f: emptyObject, s: 'o' },
    { n: 'nonEmptyObject', f: nonEmptyObject, s: 'o' },
    { n: 'instanceStrict', f: instanceStrict, s: 't' },
    { n: 'instance', f: instance, s: 't' },
    { n: 'like', f: like, s: 't' },
    { n: 'array', f: array, s: 'a' },
    { n: 'emptyArray', f: emptyArray, s: 'a' },
    { n: 'nonEmptyArray', f: nonEmptyArray, s: 'a' },
    { n: 'arrayLike', f: arrayLike, s: 'al' },
    { n: 'iterable', f: iterable, s: 'i' },
    { n: 'date', f: date, s: 'd' },
    { n: 'function', f: isFunction, s: 'f' },
    { n: 'hasLength', f: hasLength, s: 'l' },
  ].map(function (data) {
    var n = data.n;
    messages[n] = 'Invalid ' + strings[data.s || 'n'];
    predicates[n] = data.f;
  });

  functions = {
    apply: apply,
    map: map,
    all: all,
    any: any
  };

  collections = [ 'array', 'arrayLike', 'iterable', 'object' ];
  slice = Array.prototype.slice;

  functions = mixin(functions, predicates);
  assert = createModifiedPredicates(assertModifier, assertImpl);
  not = createModifiedPredicates(notModifier, notImpl);
  maybe = createModifiedPredicates(maybeModifier, maybeImpl);
  assert.not = createModifiedModifier(assertModifier, not);
  assert.maybe = createModifiedModifier(assertModifier, maybe);

  collections.forEach(createOfPredicates);
  createOfModifiers(assert, assertModifier);
  createOfModifiers(not, notModifier);
  collections.forEach(createMaybeOfModifiers);

  exportFunctions(mixin(functions, {
    assert: assert,
    not: not,
    maybe: maybe
  }));

  /**
   * Public function `equal`.
   *
   * Returns true if `lhs` and `rhs` are strictly equal, without coercion.
   * Returns false otherwise.
   */
  function equal (lhs, rhs) {
    return lhs === rhs;
  }

  /**
   * Public function `undefined`.
   *
   * Returns true if `data` is undefined, false otherwise.
   */
  function isUndefined (data) {
    return data === undefined;
  }

  /**
   * Public function `null`.
   *
   * Returns true if `data` is null, false otherwise.
   */
  function isNull (data) {
    return data === null;
  }

  /**
   * Public function `assigned`.
   *
   * Returns true if `data` is not null or undefined, false otherwise.
   */
  function assigned (data) {
    return ! isUndefined(data) && ! isNull(data);
  }

  /**
   * Public function `zero`.
   *
   * Returns true if `data` is zero, false otherwise.
   */
  function zero (data) {
    return data === 0;
  }

  /**
   * Public function `infinity`.
   *
   * Returns true if `data` is positive or negative infinity, false otherwise.
   */
  function infinity (data) {
    return data === Number.POSITIVE_INFINITY || data === Number.NEGATIVE_INFINITY;
  }

  /**
   * Public function `number`.
   *
   * Returns true if `data` is a number, false otherwise.
   */
  function number (data) {
    return typeof data === 'number' &&
      isNaN(data) === false &&
      data !== Number.POSITIVE_INFINITY &&
      data !== Number.NEGATIVE_INFINITY;
  }

  /**
   * Public function `integer`.
   *
   * Returns true if `data` is an integer, false otherwise.
   */
  function integer (data) {
    return number(data) && data % 1 === 0;
  }

  /**
   * Public function `even`.
   *
   * Returns true if `data` is an even number, false otherwise.
   */
  function even (data) {
    return number(data) && data % 2 === 0;
  }

  /**
   * Public function `odd`.
   *
   * Returns true if `data` is an odd number, false otherwise.
   */
  function odd (data) {
    return integer(data) && !even(data);
  }

  /**
   * Public function `greater`.
   *
   * Returns true if `lhs` is a number greater than `rhs`, false otherwise.
   */
  function greater (lhs, rhs) {
    return number(lhs) && lhs > rhs;
  }

  /**
   * Public function `less`.
   *
   * Returns true if `lhs` is a number less than `rhs`, false otherwise.
   */
  function less (lhs, rhs) {
    return number(lhs) && lhs < rhs;
  }

  /**
   * Public function `between`.
   *
   * Returns true if `data` is a number between `x` and `y`, false otherwise.
   */
  function between (data, x, y) {
    if (x < y) {
      return greater(data, x) && less(data, y);
    }

    return less(data, x) && greater(data, y);
  }

  /**
   * Public function `greaterOrEqual`.
   *
   * Returns true if `lhs` is a number greater than or equal to `rhs`, false
   * otherwise.
   */
  function greaterOrEqual (lhs, rhs) {
    return number(lhs) && lhs >= rhs;
  }

  /**
   * Public function `lessOrEqual`.
   *
   * Returns true if `lhs` is a number less than or equal to `rhs`, false
   * otherwise.
   */
  function lessOrEqual (lhs, rhs) {
    return number(lhs) && lhs <= rhs;
  }

  /**
   * Public function `inRange`.
   *
   * Returns true if `data` is a number in the range `x..y`, false otherwise.
   */
  function inRange (data, x, y) {
    if (x < y) {
      return greaterOrEqual(data, x) && lessOrEqual(data, y);
    }

    return lessOrEqual(data, x) && greaterOrEqual(data, y);
  }

  /**
   * Public function `positive`.
   *
   * Returns true if `data` is a positive number, false otherwise.
   */
  function positive (data) {
    return greater(data, 0);
  }

  /**
   * Public function `negative`.
   *
   * Returns true if `data` is a negative number, false otherwise.
   */
  function negative (data) {
    return less(data, 0);
  }

  /**
   * Public function `string`.
   *
   * Returns true if `data` is a string, false otherwise.
   */
  function string (data) {
    return typeof data === 'string';
  }

  /**
   * Public function `emptyString`.
   *
   * Returns true if `data` is the empty string, false otherwise.
   */
  function emptyString (data) {
    return data === '';
  }

  /**
   * Public function `nonEmptyString`.
   *
   * Returns true if `data` is a non-empty string, false otherwise.
   */
  function nonEmptyString (data) {
    return string(data) && data !== '';
  }

  /**
   * Public function `contains`.
   *
   * Returns true if `data` is a string that contains `substring`, false
   * otherwise.
   */
  function contains (data, substring) {
    return string(data) && data.indexOf(substring) !== -1;
  }

  /**
   * Public function `match`.
   *
   * Returns true if `data` is a string that matches `regex`, false otherwise.
   */
  function match (data, regex) {
    return string(data) && !! data.match(regex);
  }

  /**
   * Public function `boolean`.
   *
   * Returns true if `data` is a boolean value, false otherwise.
   */
  function boolean (data) {
    return data === false || data === true;
  }

  /**
   * Public function `object`.
   *
   * Returns true if `data` is a plain-old JS object, false otherwise.
   */
  function object (data) {
    return Object.prototype.toString.call(data) === '[object Object]';
  }

  /**
   * Public function `emptyObject`.
   *
   * Returns true if `data` is an empty object, false otherwise.
   */
  function emptyObject (data) {
    return object(data) && Object.keys(data).length === 0;
  }

  /**
   * Public function `nonEmptyObject`.
   *
   * Returns true if `data` is a non-empty object, false otherwise.
   */
  function nonEmptyObject (data) {
    return object(data) && Object.keys(data).length > 0;
  }

  /**
   * Public function `instanceStrict`.
   *
   * Returns true if `data` is an instance of `prototype`, false otherwise.
   */
  function instanceStrict (data, prototype) {
    try {
      return data instanceof prototype;
    } catch (error) {
      return false;
    }
  }

  /**
   * Public function `instance`.
   *
   * Returns true if `data` is an instance of `prototype`, false otherwise.
   * Falls back to testing constructor.name and Object.prototype.toString
   * if the initial instanceof test fails.
   */
  function instance (data, prototype) {
    try {
      return instanceStrict(data, prototype) ||
        data.constructor.name === prototype.name ||
        Object.prototype.toString.call(data) === '[object ' + prototype.name + ']';
    } catch (error) {
      return false;
    }
  }

  /**
   * Public function `like`.
   *
   * Tests whether `data` 'quacks like a duck'. Returns true if `data` has all
   * of the properties of `archetype` (the 'duck'), false otherwise.
   */
  function like (data, archetype) {
    var name;

    for (name in archetype) {
      if (archetype.hasOwnProperty(name)) {
        if (data.hasOwnProperty(name) === false || typeof data[name] !== typeof archetype[name]) {
          return false;
        }

        if (object(data[name]) && like(data[name], archetype[name]) === false) {
          return false;
        }
      }
    }

    return true;
  }

  /**
   * Public function `array`.
   *
   * Returns true if `data` is an array, false otherwise.
   */
  function array (data) {
    return Array.isArray(data);
  }

  /**
   * Public function `emptyArray`.
   *
   * Returns true if `data` is an empty array, false otherwise.
   */
  function emptyArray (data) {
    return array(data) && data.length === 0;
  }

  /**
   * Public function `nonEmptyArray`.
   *
   * Returns true if `data` is a non-empty array, false otherwise.
   */
  function nonEmptyArray (data) {
    return array(data) && data.length > 0;
  }

  /**
   * Public function `arrayLike`.
   *
   * Returns true if `data` is an array-like object, false otherwise.
   */
  function arrayLike (data) {
    return assigned(data) && number(data.length);
  }

  /**
   * Public function `iterable`.
   *
   * Returns true if `data` is an iterable, false otherwise.
   */
  function iterable (data) {
    if (typeof Symbol === 'undefined') {
      // Fall back to `arrayLike` predicate in pre-ES6 environments.
      return arrayLike(data);
    }

    return assigned(data) && isFunction(data[Symbol.iterator]);
  }

  /**
   * Public function `includes`.
   *
   * Returns true if `data` contains `value`, false otherwise.
   */
  function includes (data, value) {
    var iterator, iteration;

    if (not.assigned(data)) {
      return false;
    }

    try {
      if (typeof Symbol !== 'undefined' && data[Symbol.iterator] && isFunction(data.values)) {
        iterator = data.values();

        do {
          iteration = iterator.next();

          if (iteration.value === value) {
            return true;
          }
        } while (! iteration.done);

        return false;
      }

      Object.keys(data).forEach(function (key) {
        if (data[key] === value) {
          throw 0;
        }
      });
    } catch (ignore) {
      return true;
    }

    return false;
  }

  /**
   * Public function `hasLength`.
   *
   * Returns true if `data` has a length property that equals `length`, false
   * otherwise.
   */
  function hasLength (data, length) {
    return assigned(data) && data.length === length;
  }

  /**
   * Public function `date`.
   *
   * Returns true if `data` is a valid date, false otherwise.
   */
  function date (data) {
    try {
      return instance(data, Date) && integer(data.getTime());
    } catch (error) {
      return false;
    }
  }

  /**
   * Public function `function`.
   *
   * Returns true if `data` is a function, false otherwise.
   */
  function isFunction (data) {
    return typeof data === 'function';
  }

  /**
   * Public function `apply`.
   *
   * Maps each value from the `data` to the corresponding predicate and returns
   * the result array. If the same function is to be applied across all of the
   * data, a single predicate function may be passed in.
   *
   */
  function apply (data, predicates) {
    assert.array(data);

    if (isFunction(predicates)) {
      return data.map(function (value) {
        return predicates(value);
      });
    }

    assert.array(predicates);
    assert.hasLength(data, predicates.length);

    return data.map(function (value, index) {
      return predicates[index](value);
    });
  }

  /**
   * Public function `map`.
   *
   * Maps each value from the `data` to the corresponding predicate and returns
   * the result object. Supports nested objects. If the `data` is not nested and
   * the same function is to be applied across all of it, a single predicate
   * function may be passed in.
   *
   */
  function map (data, predicates) {
    assert.object(data);

    if (isFunction(predicates)) {
      return mapSimple(data, predicates);
    }

    assert.object(predicates);

    return mapComplex(data, predicates);
  }

  function mapSimple (data, predicate) {
    var result = {};

    Object.keys(data).forEach(function (key) {
      result[key] = predicate(data[key]);
    });

    return result;
  }

  function mapComplex (data, predicates) {
    var result = {};

    Object.keys(predicates).forEach(function (key) {
      var predicate = predicates[key];

      if (isFunction(predicate)) {
        if (not.assigned(data)) {
          result[key] = !!predicate.m;
        } else {
          result[key] = predicate(data[key]);
        }
      } else if (object(predicate)) {
        result[key] = mapComplex(data[key], predicate);
      }
    });

    return result;
  }

  /**
   * Public function `all`
   *
   * Check that all boolean values are true
   * in an array (returned from `apply`)
   * or object (returned from `map`).
   *
   */
  function all (data) {
    if (array(data)) {
      return testArray(data, false);
    }

    assert.object(data);

    return testObject(data, false);
  }

  function testArray (data, result) {
    var i;

    for (i = 0; i < data.length; i += 1) {
      if (data[i] === result) {
        return result;
      }
    }

    return !result;
  }

  function testObject (data, result) {
    var key, value;

    for (key in data) {
      if (data.hasOwnProperty(key)) {
        value = data[key];

        if (object(value) && testObject(value, result) === result) {
          return result;
        }

        if (value === result) {
          return result;
        }
      }
    }

    return !result;
  }

  /**
   * Public function `any`
   *
   * Check that at least one boolean value is true
   * in an array (returned from `apply`)
   * or object (returned from `map`).
   *
   */
  function any (data) {
    if (array(data)) {
      return testArray(data, true);
    }

    assert.object(data);

    return testObject(data, true);
  }

  function mixin (target, source) {
    Object.keys(source).forEach(function (key) {
      target[key] = source[key];
    });

    return target;
  }

  /**
   * Public modifier `assert`.
   *
   * Throws if `predicate` returns false.
   */
  function assertModifier (predicate, defaultMessage) {
    return function () {
      assertPredicate(predicate, arguments, defaultMessage);
    };
  }

  function assertPredicate (predicate, args, defaultMessage) {
    var argCount = predicate.l || predicate.length;
    var message = args[argCount];
    var ErrorType = args[argCount + 1];
    assertImpl(
      predicate.apply(null, args),
      nonEmptyString(message) ? message : defaultMessage,
      isFunction(ErrorType) ? ErrorType : TypeError
    );
  }

  function assertImpl (value, message, ErrorType) {
    if (value === false) {
      throw new (ErrorType || Error)(message || 'Assertion failed');
    }
  }

  /**
   * Public modifier `not`.
   *
   * Negates `predicate`.
   */
  function notModifier (predicate) {
    var modifiedPredicate = function () {
      return notImpl(predicate.apply(null, arguments));
    };
    modifiedPredicate.l = predicate.length;
    return modifiedPredicate;
  }

  function notImpl (value) {
    return !value;
  }

  /**
   * Public modifier `maybe`.
   *
   * Returns true if predicate argument is  null or undefined,
   * otherwise propagates the return value from `predicate`.
   */
  function maybeModifier (predicate) {
    var modifiedPredicate = function () {
      if (not.assigned(arguments[0])) {
        return true;
      }

      return predicate.apply(null, arguments);
    };
    modifiedPredicate.l = predicate.length;

    // Hackishly indicate that this is a maybe.xxx predicate.
    // Without this flag, the alternative would be to iterate
    // through the maybe predicates or use indexOf to check,
    // which would be time-consuming.
    modifiedPredicate.m = true;

    return modifiedPredicate;
  }

  function maybeImpl (value) {
    if (assigned(value) === false) {
      return true;
    }

    return value;
  }

  /**
   * Public modifier `of`.
   *
   * Applies the chained predicate to members of the collection.
   */
  function ofModifier (target, type, predicate) {
    var modifiedPredicate = function () {
      var collection, args;

      collection = arguments[0];

      if (target === 'maybe' && not.assigned(collection)) {
        return true;
      }

      if (!type(collection)) {
        return false;
      }

      collection = coerceCollection(type, collection);
      args = slice.call(arguments, 1);

      try {
        collection.forEach(function (item) {
          if (
            (target !== 'maybe' || assigned(item)) &&
            !predicate.apply(null, [ item ].concat(args))
          ) {
            // TODO: Replace with for...of when ES6 is required.
            throw 0;
          }
        });
      } catch (ignore) {
        return false;
      }

      return true;
    };
    modifiedPredicate.l = predicate.length;
    return modifiedPredicate;
  }

  function coerceCollection (type, collection) {
    switch (type) {
      case arrayLike:
        return slice.call(collection);
      case object:
        return Object.keys(collection).map(function (key) {
          return collection[key];
        });
      default:
        return collection;
    }
  }

  function createModifiedPredicates (modifier, object) {
    return createModifiedFunctions([ modifier, predicates, object ]);
  }

  function createModifiedFunctions (args) {
    var modifier, object, functions, result;

    modifier = args.shift();
    object = args.pop();
    functions = args.pop();

    result = object || {};

    Object.keys(functions).forEach(function (key) {
      Object.defineProperty(result, key, {
        configurable: false,
        enumerable: true,
        writable: false,
        value: modifier.apply(null, args.concat(functions[key], messages[key]))
      });
    });

    return result;
  }

  function createModifiedModifier (modifier, modified) {
    return createModifiedFunctions([ modifier, modified, null ]);
  }

  function createOfPredicates (key) {
    predicates[key].of = createModifiedFunctions(
      [ ofModifier.bind(null, null), predicates[key], predicates, null ]
    );
  }

  function createOfModifiers (base, modifier) {
    collections.forEach(function (key) {
      base[key].of = createModifiedModifier(modifier, predicates[key].of);
    });
  }

  function createMaybeOfModifiers (key) {
    maybe[key].of = createModifiedFunctions(
      [ ofModifier.bind(null, 'maybe'), predicates[key], predicates, null ]
    );
    assert.maybe[key].of = createModifiedModifier(assertModifier, maybe[key].of);
    assert.not[key].of = createModifiedModifier(assertModifier, not[key].of);
  }

  function exportFunctions (functions) {
    if (typeof define === 'function' && define.amd) {
      define(function () {
        return functions;
      });
    } else if (typeof module !== 'undefined' && module !== null && module.exports) {
      module.exports = functions;
    } else {
      globals.check = functions;
    }
  }
}(this));

},{}],2:[function(require,module,exports){
module.exports = update => {

  let placeholders = {};

  function addObserver(id) {
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        mutation.addedNodes.forEach(node => {
          if (node.getAttribute && node.getAttribute('data-lr')) {
            if (!node.getAttribute('id')) {
              throw new Error('Could not create an update event for component, id is missing: ', node);
            }
            const updateType = node.getAttribute('id') + node.getAttribute('data-lr').slice(0, 1).toUpperCase() + node.getAttribute('data-lr').slice(1);
            update({ matchValue : window.location.pathname, updateType });
          }
        });
      });
    });

    // pass in the target node, as well as the observer options
    observer.observe(document.querySelector(id), { attributes : false, childList : true, subtree : false });
    placeholders[id] = observer;
  }

  const exposed = {
    render(html, id) {
      if (!placeholders[id]) {
        addObserver(id);
      }
      if (!document.querySelector(id)) {
        throw new Error(`Trying to render, but could not find placeholder ${ id }`);
      }
      document.querySelector(id).innerHTML = html;
    }
  };

  document.addEventListener('DOMContentLoaded', () => {
    [].slice.call(document.querySelectorAll('[data-lr="loaded"]')).forEach(component => {
      if (!component.getAttribute('id')) {
        throw new Error('Found component, but id is missing: ', component);
      }
      update({ matchValue : window.location.pathname, updateType : component.getAttribute('id') + 'Loaded' });
    });
  });

  return exposed;
};

},{}],3:[function(require,module,exports){
module.exports = update => {

  document.addEventListener('click', event => {
    if (event.target.nodeName.toLowerCase() === 'a' &&
        event.target.getAttribute('href') &&
        event.target.getAttribute('href')[0] === '/') {
      event.preventDefault();
      const url = event.target.getAttribute('href');
      history.pushState({ url }, url, url);
      update({ matchValue : url }, { url });
      window.scrollTo(0, 0);
    }
  });

  // Event for back and forward through history
  window.onpopstate = function(request) {
    if (request && request.state && request.state.url) {
      update({ matchValue : request.state.url }, request.state);
    }
  };

  return {
    redirect(url) {
      history.pushState({ url }, url, url);
      update({ matchValue : url }, { url });
    }
  };
}

},{}],4:[function(require,module,exports){
const check = require('check-types');

module.exports = (environmentId, options = {}) => {
  const defaultUpdateType     = 'GET';
  let middlewareStackRunning  = false;
  let middlewareStack         = [];
  let updateStack             = [];
  let relay;
  let selectedParser          = { add : () => {}, parse : matchValue => { return { path : matchValue, parameters : {} } } };
  let resetAfterCycle         = true;
  let traditional             = [];
  let extensions              = {};
  let availableMiddleware     = {};
  let executingEnvironmentId  = environmentId;
  let selectedEnvironmentIds  = [environmentId];
  let environments            = { [environmentId] : environment(environmentId) };
  const exposed               = { extension, middleware, where, run, error, noMatch, done, update, parser };

  if (options.resetAfterCycle !== undefined) {
    check.assert.boolean(options.resetAfterCycle, 'resetAfterCycle needs to be a boolean');
    resetAfterCycle = options.resetAfterCycle;
  }

  function environment(id) {
    check.assert.not.undefined(id, 'Environment id cannot be empty');
    check.assert.match(id, /^[a-z0-9]+$/i, 'Environment id needs to be a string containing only letters and or numbers');
    return { id, run : {}, noMatch : {}, error : {}, done : {} };
  }

  function parser(parser) {
    check.assert.function(parser.add, 'Parser needs to have a method called "add"');
    check.assert.function(parser.parse, 'Parser needs to have a method called "parse"');
    selectedParser = parser;
    return exposed;
  }

  function extension(id, extension, isUpdater = false) {
    check.assert.not.undefined(id, 'Extension id cannot be empty');
    check.assert.not.undefined(extension, 'Extension cannot be empty');
    check.assert.match(id, /^[a-z0-9]+$/i, 'Extension id needs to be a string containing only letters and or numbers');
    check.assert.not.assigned(extensions[id], `"${ id }" has already been defined as an extension`);
    extensions[id] = isUpdater ? extension(update) : extension;
    return exposed;
  }

  function middleware(newMiddleware, ...traditionals) {
    check.assert.nonEmptyObject(newMiddleware, 'Provided middleware needs to be a non empty object');
    Object.keys(newMiddleware).forEach(id => {
      check.assert.not.assigned(availableMiddleware[id], `"${ id }" has already been defined as middleware`);
      check.assert.function(newMiddleware[id], `"${ id }" middleware is not a function`);
    });
    if (traditionals.length) {
      check.assert.array.of.string(traditionals, 'All traditional middleware names need to be strings');
      traditionals
        .forEach((id, index) => {
          check.assert.equal(traditionals.indexOf(id), index, `Duplicate values found for traditional middleware "${ id }"`);
          check.assert.equal(traditional.indexOf(id), -1, `"${ id }" has already been defined as a traditional middleware function`);
        });
      traditional = [...traditional, ...traditionals];
    }
    availableMiddleware = Object.assign({}, availableMiddleware, newMiddleware);
    return exposed;
  }

  function where(...environmentIds) {
    check.assert.greater(environmentIds.length, 0, 'Where method missing parameters');
    environmentIds.forEach(id => {
      check.assert.not.undefined(id, 'Environment id cannot be empty');
      check.assert.match(id, /^[a-z0-9]+$/i, 'Environment id needs to be a string containing only letters and or numbers');
      if (!environments[id]) {
        environments[id] = environment(id);
      }
    });
    selectedEnvironmentIds = environmentIds;
    return exposed;
  }

  function run(matchValue, middlewareId, updateType = defaultUpdateType) {
    check.assert.not.undefined(matchValue, 'Match value cannot be empty');
    check.assert.string(matchValue, 'Match value needs to be a string');
    check.assert.not.undefined(middlewareId, 'Middleware id cannot be empty');
    check.assert.match(middlewareId, /^[a-z0-9\.]+$/i, 'Middleware id needs to be a string containing only letters,numbers and an optional "."');
    check.assert.match(updateType, /^[a-z0-9]+$/i, 'Update type needs to be a string containing only letters and or numbers');
    selectedParser.add(matchValue);
    selectedEnvironmentIds.forEach(id => {
      Array.isArray(environments[id].run[updateType])
        ? environments[id].run[updateType].push({ middlewareId, matchValue })
        : environments[id].run[updateType] = [{ middlewareId, matchValue }];
    });
    return exposed;
  }

  function error(middlewareId, updateType = defaultUpdateType) {
    check.assert.not.undefined(middlewareId, 'Middleware id cannot be empty');
    check.assert.match(updateType, /^[a-z0-9]+$/i, 'Update type needs to be a string containing only letters and or numbers');
    check.assert.match(middlewareId, /^[a-z0-9\.]+$/i, 'Middleware id needs to be a string containing only letters,numbers and an optional "."');
    selectedEnvironmentIds.forEach(id => {
      Array.isArray(environments[id].error[updateType])
        ? environments[id].error[updateType].push(middlewareId)
        : environments[id].error[updateType] = [middlewareId];
    });
    return exposed;
  }

  function noMatch(middlewareId, updateType = defaultUpdateType) {
    check.assert.not.undefined(middlewareId, 'Middleware id cannot be empty');
    check.assert.match(updateType, /^[a-z0-9]+$/i, 'Update type needs to be a string containing only letters and or numbers');
    check.assert.match(middlewareId, /^[a-z0-9\.]+$/i, 'Middleware id needs to be a string containing only letters,numbers and an optional "."');
    selectedEnvironmentIds.forEach(id => {
      Array.isArray(environments[id].noMatch[updateType])
        ? environments[id].noMatch[updateType].push(middlewareId)
        : environments[id].noMatch[updateType] = [middlewareId];
    });
    return exposed;
  }

  function done(middlewareId, updateType = defaultUpdateType) {
    check.assert.not.undefined(middlewareId, 'Middleware id cannot be empty');
    check.assert.match(updateType, /^[a-z0-9]+$/i, 'Update type needs to be a string containing only letters and or numbers');
    check.assert.match(middlewareId, /^[a-z0-9\.]+$/i, 'Middleware id needs to be a string containing only letters,numbers and an optional "."');
    selectedEnvironmentIds.forEach(id => {
      Array.isArray(environments[id].done[updateType])
        ? environments[id].done[updateType].push(middlewareId)
        : environments[id].done[updateType] = [middlewareId];
    });
    return exposed;
  }

  function update(options, ...parameters) {
    updateStack.push({ options, parameters });
    if (middlewareStackRunning === false) {
      runMiddlewareStack();
    }
    return exposed;
  }

  function updateRelay(options) {
    updateStack.push({ options, parameters : [] });
    if (middlewareStackRunning === false) {
      runMiddlewareStack();
    }
  }

  function exit() {
    middlewareStack = [];
    runMiddlewareStack();
  }

  async function runMiddlewareStack() {
    const update = updateStack.shift();
    if (update) {
      if (resetAfterCycle || !relay) { relay = { extensions, update : updateRelay, exit } }
      middlewareStackRunning = true;
      check.assert.assigned(update.options.matchValue, 'Update function cannot find a matchValue');
      let   matchValue  = selectedParser.parse(update.options.matchValue);
            relay       = Object.assign({}, relay, { parameters : matchValue.parameters });
            matchValue  = matchValue.path;
      const updateType  = update.options.updateType ? update.options.updateType : defaultUpdateType;
      const environment = environments[executingEnvironmentId];
      const done        = environment.done[updateType] ? environment.done[updateType] : [];
      const noMatch     = environment.noMatch[updateType] ? environment.noMatch[updateType] : [];
      const error       = environment.error[updateType] ? environment.error[updateType] : [];
      middlewareStack   = environment.run[updateType]
        ? environment.run[updateType]
          .filter(middleware => (middleware.matchValue === matchValue || middleware.matchValue === '*'))
          .map(middleware => middleware.middlewareId)
        : [];
      if (middlewareStack.length === 0) { middlewareStack = noMatch; }
      middlewareStack = [...middlewareStack, ...done];
      if (middlewareStack.length > 0 ) {
        await thunkifyMiddleware(middlewareStack.shift())();
      } else {
        runMiddlewareStack();
      }

      function mergeRelay(defined = {}) {
        check.assert.object(defined, 'Relay additions need to be an object');
        check.assert.not.assigned(defined.extensions, 'Cannot assign extensions as a relay property, this is a reserved property');
        check.assert.not.assigned(defined.exit, 'Cannot assign exit as a relay property, this is a reserved property');
        check.assert.not.assigned(defined.update, 'Cannot assign update as a relay property, this is a reserved property');
        check.assert.not.assigned(defined.parameters, 'Cannot assign parameters as a relay property, this is a reserved property');
        relay = Object.assign({}, relay, defined);
      }

      function thunkifyMiddleware(id, final = false) {
        const callback = availableMiddleware[id];
        check.assert.assigned(callback, `Middleware ${ id } not found`);
        check.assert.function(callback, 'Middleware needs to be a function');
        return async function(defined) {
          try {
            mergeRelay(defined);
            const next     = middlewareStack.length === 0
              ? (defined) => { mergeRelay(defined); runMiddlewareStack(); }
              : thunkifyMiddleware(middlewareStack.shift(), final);
            let parameters = [next, relay, ...update.parameters];
            if (traditional.indexOf(id) > -1 && relay.error) {
              parameters = [...update.parameters, next, relay.error];
            } else if (traditional.indexOf(id) > -1) {
              parameters = [...update.parameters, next];
            }
            await callback(...parameters);
          } catch (errorMessage) {
            if (final) {
              console.error(errorMessage);
            } else {
              relay = { error : errorMessage, extensions, update : updateRelay, exit };
              middlewareStack = error;
              if (middlewareStack.length === 0) { console.warn('No "error" middleware found'); console.error(errorMessage); }
              middlewareStack = [...middlewareStack, ...done];
              if (middlewareStack.length > 0 ) { await thunkifyMiddleware(middlewareStack.shift(), true)(); }
            }
          }
        }
      }
    } else {
      middlewareStackRunning = false;
    }
  }
  return exposed;
};

},{"check-types":1}],5:[function(require,module,exports){
'use strict';var router=require('lr-client-router'),renderer=require('lr-client-renderer'),road=require('lr-main')('client');road.extension('router',router,!0).extension('renderer',renderer,!0).middleware({'events.navigation':require('../middleware/events/navigation')}),require('./road')(road);

},{"../middleware/events/navigation":31,"./road":6,"lr-client-renderer":2,"lr-client-router":3,"lr-main":4}],6:[function(require,module,exports){
'use strict';module.exports=function(a){a.where('webserver','client').middleware({debug:function debug(b,c,d){console.log(d.url),b()},'components.navigation':require('../middleware/components/navigation'),'components.home':require('../middleware/components/home'),'components.reference':require('../middleware/components/reference'),'components.lrMain':require('../middleware/components/reference/lrMain'),'components.lrServerRouter':require('../middleware/components/reference/lrServerRouter'),'components.lrServerRenderer':require('../middleware/components/reference/lrServerRenderer'),'components.lrClientRouter':require('../middleware/components/reference/lrClientRouter'),'components.lrClientRenderer':require('../middleware/components/reference/lrClientRenderer'),'components.lrUrlParser':require('../middleware/components/reference/lrUrlParser'),'components.faq':require('../middleware/components/faq'),'components.error':require('../middleware/components/error'),'components.noMatch':require('../middleware/components/noMatch'),'components.guide':require('../middleware/components/guide'),'components.guideSetup':require('../middleware/components/guide/setup'),'components.guideHelloWorld':require('../middleware/components/guide/helloWorld'),'components.guideAddingServerSideRenderer':require('../middleware/components/guide/addingServerSideRenderer'),'components.guideHandlingStaticContent':require('../middleware/components/guide/handlingStaticContent'),'components.guideMakeASinglePageApp':require('../middleware/components/guide/makeASinglePageApp'),'components.guideWorkingWithDOMEvents':require('../middleware/components/guide/workingWithDOMEvents'),'components.guideAddingUrlParametersViaAParser':require('../middleware/components/guide/addingUrlParametersViaAParser'),'components.guideUpdateAndMiddlewareStack':require('../middleware/components/guide/updateAndMiddlewareStack'),'components.guideWritingExtensions':require('../middleware/components/guide/writingExtensions'),'components.guideWorkingWithData':require('../middleware/components/guide/workingWithData'),'components.guideWritingParsers':require('../middleware/components/guide/writingParsers')}).run('*','debug').where('webserver').run('*','layouts.default').noMatch('layouts.default').where('client').run('*','events.navigation','navigationLoaded').where('webserver','client').run('*','components.navigation').run('/','components.home').run('/guide','components.guide').run('/guide/setup','components.guideSetup').run('/guide/hello-world','components.guideHelloWorld').run('/guide/adding-server-side-renderer','components.guideAddingServerSideRenderer').run('/guide/handling-static-content','components.guideHandlingStaticContent').run('/guide/make-a-single-page-app','components.guideMakeASinglePageApp').run('/guide/working-with-dom-events','components.guideWorkingWithDOMEvents').run('/guide/adding-url-parameters-via-a-parser','components.guideAddingUrlParametersViaAParser').run('/guide/update-and-middleware-stack','components.guideUpdateAndMiddlewareStack').run('/guide/writing-extensions','components.guideWritingExtensions').run('/guide/working-with-data','components.guideWorkingWithData').run('/guide/writing-parsers','components.guideWritingParsers').run('/reference','components.reference').run('/reference/lr-main','components.lrMain').run('/reference/lr-server-router','components.lrServerRouter').run('/reference/lr-server-renderer','components.lrServerRenderer').run('/reference/lr-client-router','components.lrClientRouter').run('/reference/lr-client-renderer','components.lrClientRenderer').run('/reference/lr-url-parser','components.lrUrlParser').run('/faq','components.faq').noMatch('components.noMatch').error('components.error').where('webserver').done('response.html')};

},{"../middleware/components/error":7,"../middleware/components/faq":8,"../middleware/components/guide":13,"../middleware/components/guide/addingServerSideRenderer":9,"../middleware/components/guide/addingUrlParametersViaAParser":10,"../middleware/components/guide/handlingStaticContent":11,"../middleware/components/guide/helloWorld":12,"../middleware/components/guide/makeASinglePageApp":14,"../middleware/components/guide/setup":15,"../middleware/components/guide/updateAndMiddlewareStack":16,"../middleware/components/guide/workingWithDOMEvents":17,"../middleware/components/guide/workingWithData":18,"../middleware/components/guide/writingExtensions":19,"../middleware/components/guide/writingParsers":20,"../middleware/components/home":21,"../middleware/components/navigation":22,"../middleware/components/noMatch":23,"../middleware/components/reference":24,"../middleware/components/reference/lrClientRenderer":25,"../middleware/components/reference/lrClientRouter":26,"../middleware/components/reference/lrMain":27,"../middleware/components/reference/lrServerRenderer":28,"../middleware/components/reference/lrServerRouter":29,"../middleware/components/reference/lrUrlParser":30}],7:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n    <section id="error" data-lr="loaded">\n      <h1>Error</h1>\n      <pre>'+b.error+'</pre>\n    </section>\n  ','article'),a()};

},{}],8:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n        <section id="" data="lr-loaded">\n          <h1 id="faq">Faq</h1>\n<p>Answers to some common questions you might have. Cannot find an answer? Please open an <a href="https://github.com/lagoon-road/lr-main/issues/new">issue</a> on Github. I will keep this list up to date so all questions asked on Github that have any merit will be added to this list.</p>\n<ul class="submenu">\n  <li><a href="#which-versions-of-node-are-supported-">Which versions of node are supported?</a></li>\n  <li><a href="#does-a-single-road-not-create-overhead-in-other-environments-">Does a single road not create overhead in other environments?</a></li>\n  <li><a href="#what-is-the-best-directory-structure-for-my-project-">What is the best directory structure for my project?</a></li>\n  <li><a href="#why-is-there-a-different-middleware-argument-signature-">Why is there a different middleware argument signature?</a></li>\n  <li><a href="#do-i-have-to-call-next-in-the-done-middleware-">Do I have to call next in the done middleware?</a></li>\n  <li><a href="#i-want-to-keep-the-relay-object-populated-after-a-request-how-do-i-do-that-">I want to keep the relay object populated after a request, how do I do that?</a></li>\n  <li><a href="#does-the-order-of-how-i-attch-middleware-to-the-road-matter-">Does the order of how I attch middleware to the road matter?</a></li>\n  <li><a href="#who-created-lagoon-road-">Who created Lagoon road?</a></li>\n  <li><a href="#where-does-the-name-come-from-">Where does the name come from?</a></li>\n</ul>\n\n<h3 id="which-versions-of-node-are-supported-">Which versions of node are supported?</h3>\n<p>The packages have hardly any dependencies and are very much just plain javascript, so everything from node 4.x up I expect to work. The code is written with ES6 so you might need to compile your code first with Babel to get it to run. Best practice is to use the newest version of node, for the simple reason that I haven&#39;t tested older versions. I developed with node 7.6.x</p>\n<h3 id="does-a-single-road-not-create-overhead-in-other-environments-">Does a single road not create overhead in other environments?</h3>\n<p>Yes, combining the middleware in a single place, will create overhead. But compared to what you gain from having everything connected in a single place, it is negligible. You will only create some extra properties on the internal objects within the core. Whenever the update event is fired the matches are done based on object key matches, so there is no extra filtering needed. Performance wise not really an issue.</p>\n<h3 id="what-is-the-best-directory-structure-for-my-project-">What is the best directory structure for my project?</h3>\n<p>Lagoon road doesn&#39;t force any structure on you. That is the phylosophy of Lagoon road, that you don&#39;t have to tie yourself down to any methodologies or structures. You want to work more in a component based manner, you can do so. Want to seperate your scripts from your styles, because you reuse your css over multiple components, also possible. This is the structure that I&#39;ve used for this website:</p>\n<pre><code>- source\n| <span class="hljs-type">- bootstrap</span>\n  | <span class="hljs-type">- client</span>.js\n  | <span class="hljs-type">- server</span>.js\n  | <span class="hljs-type">- road</span>.js\n| <span class="hljs-type">- extensions</span>\n  | <span class="hljs-type">- settings</span>\n    | <span class="hljs-type">- webserver</span>.js\n| <span class="hljs-type">- middleware</span>\n  | <span class="hljs-type">- components</span>\n    | <span class="hljs-type">- .. every</span> component <span class="hljs-built_in">in</span> a single file\n  | <span class="hljs-type">- layouts</span>\n    | <span class="hljs-type">.. every</span> layout <span class="hljs-built_in">in</span> a single file\n  | <span class="hljs-type">- events</span>\n    | <span class="hljs-type">- .. client</span> side dom code, every component <span class="hljs-built_in">in</span> a single file\n  | <span class="hljs-type">- response</span>\n    | <span class="hljs-type">- response</span>.js (html response <span class="hljs-keyword">for</span> the webserver)\n| <span class="hljs-type">- stylesheets</span>\n  | <span class="hljs-type">- components</span>\n    | <span class="hljs-type">.. every</span> component <span class="hljs-built_in">in</span> a single file\n  | <span class="hljs-type">- layouts</span>\n    | <span class="hljs-type">.. every</span> layout <span class="hljs-built_in">in</span> a single file\n  | <span class="hljs-type">- .. some</span> more general styles, like animation and typography\n  | <span class="hljs-type">- styles</span>.css (importing all other styles)\n</code></pre><p>Then all client side code will be pass through babel and browserify and the minifier. View the <a href="https://github.com/lagoon-road/lr-website/blob/master/package.json">package.json</a> and the <a href="https://github.com/lagoon-road/lr-website">lr-website code</a></p>\n<h3 id="why-is-there-a-different-middleware-argument-signature-">Why is there a different middleware argument signature?</h3>\n<p>The reason that Lagoon road doesn&#39;t follow the standard argument order of, <code>request</code>, <code>response</code>, <code>next</code> and an optional <code>error</code> is because we are not only handling http requests and responses. In frameworks like Expressjs everything is centered around the the http protocol. In that setup it makes sense to have <code>request</code> and <code>response</code> come first. In Lagoon road we don&#39;t tie in http as the only protocol so the parameters for your middleware might be different. Same goes for the client. If we would have kept the order the same there will be a lot of cases where you are specifying parameters that are not really used. If you have traditional middleware that you want to plug in, you can make it run in the traditional order. See the <a href="/reference/lr-main">lr-main reference</a> for more information.</p>\n<h3 id="do-i-have-to-call-next-in-the-done-middleware-">Do I have to call next in the done middleware?</h3>\n<p>Yes, you always need to call the <code>next()</code> function, no matter what. Read why in the <a href="/guide/update-and-middleware-stack">update and middleware stack guide</a>.</p>\n<h3 id="i-want-to-keep-the-relay-object-populated-after-a-request-how-do-i-do-that-">I want to keep the relay object populated after a request, how do I do that?</h3>\n<p>This is pretty straight forward. You can just set the <code>resetAfterCycle</code> option on the core initialization. Check the <a href="/reference/lr-main">reference</a> for more information.</p>\n<h3 id="does-the-order-of-how-i-attch-middleware-to-the-road-matter-">Does the order of how I attch middleware to the road matter?</h3>\n<p>Yes it does. The first middleware that you add, will be put first in the stack. This is why Lagoon road is simple to reason about. You just start looking from the top and see what you first match is. That will be the first middleware that will be called. Read more about the it in the <a href="/guide/update-and-middleware-stack">guide</a>.</p>\n<h3 id="who-created-lagoon-road-">Who created Lagoon road?</h3>\n<p><a href="http://royniels.nl">Me</a></p>\n<h3 id="where-does-the-name-come-from-">Where does the name come from?</h3>\n<p>The name comes from one of my favorite books, <em><a href="https://www.amazon.com/Surviving-Paradise-Year-Disappearing-Island/dp/B0044KN3CO&quot;">Surviving Paradise: One Year on a Disappearing Island</a></em>. At some point the protagonist is back on Majuro, an island in the Marshall Islands group and talks about the single road on the island.</p>\n<blockquote>\n<p>Taxis were a snap\u2014stand on the appropriate side of the street, \uFB02ag down one of the six cabs that arrived every minute, and then sit in the cool dryness of the air-conditioning and enjoy the ride. No need to tell the driver your destination: since there was only one real road, you could simply tell him when to stop.</p>\n</blockquote>\n<p>The road that he is talking about is called Lagoon road, and since I am residing on Bali, a link with islands and the single road concept seemed like a good metaphore for the single object structure of Lagoon road.</p>\n\n        </section>\n    ','article'),a()};

},{}],9:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n        <section id="" data="lr-loaded">\n          <h1 id="adding-server-side-renderer">Adding server side renderer</h1>\n<p>After creating a simple hello world example it is time to add some proper rendering to the server side. The following code uses the <code>lr-server-renderer</code> the let us easily add a template and components.</p>\n<h5 id="adding-server-side-renderer-source-bootstrap-webserver-js">adding-server-side-renderer/source/bootstrap/webserver.js</h5>\n<pre><code><span class="hljs-keyword">const</span> protocol = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'http\'</span>);\n<span class="hljs-keyword">const</span> server   = protocol.createServer();\n<span class="hljs-keyword">const</span> router   = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-server-router\'</span>)(server);\n<span class="hljs-keyword">const</span> renderer = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-server-renderer\'</span>)();\n<span class="hljs-keyword">const</span> debug    = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../extensions/debug\'</span>);\n\n<span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-main\'</span>)(<span class="hljs-string">\'webserver\'</span>)\n  .extension(<span class="hljs-string">\'router\'</span>, router, <span class="hljs-literal">true</span>)\n  .extension(<span class="hljs-string">\'renderer\'</span>, renderer)\n  .extension(<span class="hljs-string">\'debug\'</span>, debug)\n  .middleware({\n    <span class="hljs-attr">debug</span>                   : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/debug\'</span>),\n    <span class="hljs-attr">response</span>                : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/response\'</span>),\n    <span class="hljs-string">\'components.home\'</span>       : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/components/home\'</span>),\n    <span class="hljs-string">\'components.navigation\'</span> : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/components/navigation\'</span>),\n    <span class="hljs-string">\'components.contact\'</span>    : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/components/contact\'</span>),\n    <span class="hljs-string">\'layouts.default\'</span>       : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/layouts/default\'</span>),\n  })\n  .run(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'debug\'</span>)\n  .run(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'layouts.default\'</span>)\n  .run(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'components.navigation\'</span>)\n  .run(<span class="hljs-string">\'/\'</span>, <span class="hljs-string">\'components.home\'</span>)\n  .run(<span class="hljs-string">\'/contact\'</span>, <span class="hljs-string">\'components.contact\'</span>)\n  .done(<span class="hljs-string">\'response\'</span>);\n\nserver.listen(<span class="hljs-number">8080</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'server running on localhost:8080\'</span>);\n});\n</code></pre><p>As you can see we added two more extensions. The <code>renderer</code> extension and the <code>debug</code> extension. The <code>renderer</code> extension is a package by itself so we will not go into specifics over how it is implemented, but we will look at the debug extension so you have a feel how you can write a simple extension.</p>\n<blockquote>\n<p>You can find the source code for the renderer extension on <a href="https://github.com/lagoon-road/lr-server-renderer/blob/master/index.js">github</a>.</p>\n</blockquote>\n<h5 id="adding-server-side-renderer-source-extensions-debug-js">adding-server-side-renderer/source/extensions/debug.js</h5>\n<pre><code><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> {\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'DEBUG: \'</span> + message);\n}\n</code></pre><p>As you can see the <code>debug</code> extension is nothing more then a function. In our case just a function around the <code>console.log</code>. This might not be the most useful extension but it shows how you can use extensions to centralize your code. If we were to use an actual logger/debugger like <code>debug</code>, <code>morgan</code> or <code>winston</code> we can create a very thin function wrapper and use the extension in all our middleware. When you change your debugger later, you only change the extension and have all the middleware automatically use it. Pretty DRY.</p>\n<p>So how would you use the extension in your middleware? Well for that we look at the <code>debug</code> middleware.</p>\n<pre><code>module.exports = (next, relay, request) =&gt; {\n  relay.extensions.debug(<span class="hljs-symbol">`</span>Incoming request [<span class="hljs-symbol">$</span><span class="hljs-symbol">{</span> request.method <span class="hljs-symbol">}</span>]: <span class="hljs-symbol">$</span><span class="hljs-symbol">{</span> request.url <span class="hljs-symbol">}</span><span class="hljs-symbol">`</span>);\n  next();\n}\n</code></pre><p>You can see how we can access the extension by using the <code>relay</code> object.</p>\n<h3 id="relay-object">Relay object</h3>\n<p>The relay object is something that you not see in standard middleware, but the concept is pretty simple. The <code>relay</code> object is passed from middleware to middleware, hence the name relay. Every extension, or variable that you add becomes available in every middleware function that comes after it. All <code>extensions</code> are available at <code>relay.extensions.extensionName</code>.</p>\n<p>When you want to set a variable in your middleware that needs to be available to all the following middleware you simply pass and object to the <code>next</code> function like so:</p>\n<pre><code><span class="hljs-selector-tag">next</span>({ <span class="hljs-attribute">someVariable </span>: true });\n</code></pre><p>The object will automatically be merged with existing <code>relay</code> variables which makes it easy to pass on data between middleware.</p>\n<blockquote>\n<p>If you want to use the relay object as a state manager it might be handy to add all the state to a state object.</p>\n<pre><code>module.exports = (next, relay) =&gt; {\n  const <span class="hljs-keyword">state</span> = Object.assign({}, relay.<span class="hljs-keyword">state</span>, { someNewProperty : true});\n  next({ <span class="hljs-keyword">state</span> });\n}\n</code></pre><p>This way it is easy to send everything from the server to the client in the template, which saves you to make redundant calls from the client.</p>\n</blockquote>\n<h3 id="listening-for-changes">Listening for changes</h3>\n<p>Now that we added some middleware for our debugger it is time to let it listen for http requests.</p>\n<pre><code>.<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'debug\'</span>)\n</code></pre><p>As you can see we use a new method, namely <code>run</code>. The <code>run</code> method can be thought of as the <code>get</code> method in traditional middleware. Whenever a <code>GET</code> request comes in it will be triggered. The reason for not calling it get is that we are not limited to only use the http protocol. So it would make little sense to call it get. Furthermore you can see that you can use the asterix (*) symbol to listen to all <code>GET</code> requests.</p>\n<blockquote>\n<p>If you need to listen to another method, or in Lagoon road called <code>updateType</code>. You can specify a third parameter.</p>\n<pre><code>.<span class="hljs-built_in">run</span>(*, <span class="hljs-string">\'debug\'</span>, <span class="hljs-string">\'post\'</span>)\n</code></pre></blockquote>\n<h3 id="adding-a-template">Adding a template</h3>\n<p>Great so we have added a simple debug function, time to get our templating up and running. First we want to define a template.</p>\n<pre><code>module.exports = (next, relay) =&gt; {\n  relay.extensions.debug(\'selecting template\');\n  relay.extensions.renderer.template(`\n    <span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Adding client side routing<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">""</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"author"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"Roy Niels"</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"content"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n  `);\n  next();\n}\n</code></pre><p>We are using the <code>renderer</code> extension to set the template. The <code>template</code> method needs a single argument, which is a string with raw html. It has a <code>&lt;nav&gt;</code> and <code>&lt;section class=&quot;content&quot;&gt;&lt;/section&gt;</code> tag. This is were our components will be placed.</p>\n<p>Each request needs a template so we add it like we did with the <code>debug</code> middleware, with an asterix.</p>\n<pre><code>.<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'layouts.default\'</span>)\n</code></pre><p>You can see that you can easily use multiple templates for different routes if you wish to.</p>\n<blockquote>\n<p>We are passing in raw html to the renderer. Because of this it becomes very easy to use any templating engine, as long as you get a string back, you can use whatever you want. This is one of the ways that Lagoon road is unopinionated.</p>\n</blockquote>\n<h3 id="adding-a-component">Adding a component</h3>\n<p>The template is in place, time to add the components. We will look at the middleware for the contact page, all the other components use the same technique.</p>\n<pre><code><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">next</span>, relay)</span> =&gt;</span> {\n  relay.extensions.<span class="hljs-built_in">debug</span>(<span class="hljs-string">\'rendering contact\'</span>);\n  relay.extensions.renderer.render(<span class="hljs-string">\'&lt;h1&gt;This is the contact page&lt;/h1&gt;\'</span>, <span class="hljs-string">\'.content\'</span>);\n  <span class="hljs-built_in">next</span>();\n}\n</code></pre><p>We use the same renderer extension as we used for the template, but a different method, <code>render</code>. This  method takes two parameters. The first one, again a raw html string, the second one, a html selector. Just like you do when working with the regular browser DOM.</p>\n<p>Hooking it up to the road is slightly different, we want to only render the component on the <code>/contact</code> page, so we will set up the <code>matchValue</code> accordingly</p>\n<pre><code>.<span class="hljs-built_in">run</span>(<span class="hljs-string">\'/contact\'</span>, <span class="hljs-string">\'component.contact\'</span>)\n</code></pre><blockquote>\n<p><code>matchValue</code> is the first argument in the <code>run</code> method.</p>\n</blockquote>\n<h3 id="rendering-the-output">Rendering the output</h3>\n<p>We have slightly changed the response middleware to accommodate the <code>renderer</code> extension.</p>\n<pre><code><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">next</span>, relay, request, response)</span> =&gt;</span> {\n  relay.extensions.<span class="hljs-built_in">debug</span>(<span class="hljs-string">\'sending html response\'</span>);\n  response.end(relay.extensions.renderer.html());\n}\n</code></pre><p>We call the <code>html</code> method to get a fully renderer html page as a string and send that back to the client.</p>\n<p>Before we go and add the client side code to create a single page app, we want to take a look at how we can handle static content, like our javascript files, images and stylesheets.</p>\n<p>Next: <a href="/guide/handling-static-content">Handling static content</a></p>\n\n        </section>\n    ','article'),a()};

},{}],10:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n        <section id="" data="lr-loaded">\n          <h1 id="adding-url-parameters-via-a-parser">Adding url parameters via a parser</h1>\n<p>One of the most common tasks that a web server has to perform is take some dynamic parameter from the url and give that back the backend so it can handle it. In Lagoon road we use parsers for this.</p>\n<h5 id="adding-url-parameters-via-a-parser-source-bootstrap-road-js">adding-url-parameters-via-a-parser/source/bootstrap/road.js</h5>\n<pre><code><span class="hljs-keyword">const</span> debug  = require(<span class="hljs-string">\'../extensions/debug\'</span>);\n<span class="hljs-keyword">const</span> parser = require(<span class="hljs-string">\'lr-url-parser\'</span>)();\n\n<span class="hljs-keyword">module</span>.exports = road =&gt; {\n  <span class="hljs-built_in">return</span> road\n    .parser(parser)\n    .extension(<span class="hljs-string">\'debug\'</span>, debug)\n    .middleware({\n      debug                   : require(<span class="hljs-string">\'../middleware/debug\'</span>),\n      <span class="hljs-string">\'components.navigation\'</span> : require(<span class="hljs-string">\'../middleware/components/navigation\'</span>),\n      <span class="hljs-string">\'components.home\'</span>       : require(<span class="hljs-string">\'../middleware/components/home\'</span>),\n      <span class="hljs-string">\'components.contact\'</span>    : require(<span class="hljs-string">\'../middleware/components/contact\'</span>)\n    })\n    .where(<span class="hljs-string">\'webserver\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'debug\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'statics\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'layouts.default\'</span>)\n    .where(<span class="hljs-string">\'client\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'nav\'</span>, <span class="hljs-string">\'events.navigation\'</span>, <span class="hljs-string">\'domReady\'</span>)\n    .where(<span class="hljs-string">\'webserver\'</span>, <span class="hljs-string">\'client\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'components.navigation\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'/\'</span>, <span class="hljs-string">\'components.home\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'/params/:id\'</span>, <span class="hljs-string">\'components.home\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'/params/:id/:something\'</span>, <span class="hljs-string">\'components.home\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'/contact\'</span>, <span class="hljs-string">\'components.contact\'</span>)\n      .done(<span class="hljs-string">\'response\'</span>);\n}\n</code></pre><p>As you can see there is already a package for dealing with dynamic url parts, <code>lr-url-parser</code>. You can add the parser by using the <code>parser</code> method.</p>\n<pre><code>.<span class="hljs-keyword">parser</span>(<span class="hljs-keyword">parser</span>)\n</code></pre><p>You can now use dynamic url parts via the relay object, <code>relay.parameters</code>.</p>\n<blockquote>\n<p>The standard parser is for urls, but you are not limited to urls by any means. Want to analyze JSON or some other string values, <a href="/guide/writing-parsers">write are parser</a> and become as flexible as you need to be</p>\n</blockquote>\n<p>Next: <a href="/guide/update-and-middleware-stack">Update and middleware stack</a></p>\n\n        </section>\n    ','article'),a()};

},{}],11:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n        <section id="" data="lr-loaded">\n          <h1 id="handling-static-content">Handling static content</h1>\n<p><strong>Although it is possible to add middleware to handle your static files, like scripts, images and stylesheets. It is better to do this via a reverse proxy on a webserver like Nginx. Node is not the best choice when it comes to serving static content. This is way easier with a Nginx setup. It is trivial to gzip your files, add caching and catch redundant calls to your node server.\nFurthermore it is pretty straight forward to add HTTPS with let&#39;s encrypt.</strong></p>\n<p><strong>Read more about reverse proxies and Nginx in <a href="https://code.lengstorf.com/deploy-nodejs-ssl-digitalocean/">this</a> outstanding post. Although it is for a Digital Ocean droplet, it shows you very clearly how to setup a reverse proxy that you can use without Digital Ocean.</strong></p>\n<p>For testing purposes you might want to use some static middleware. The following code is mainly a copy from <a href="https://developer.mozilla.org/en-US/docs/Node_server_without_framework">here</a> with some small adjustments to accommodate Lagoon road.</p>\n<pre><code>const url  = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'url\'</span>);\nconst fs   = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'fs\'</span>);\nconst path = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'path\'</span>);\n\n<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">next</span>, relay, request, response)</span> =&gt;</span> {\n  const parsedUrl = url.parse(request.url);\n  let pathname    = `.${ parsedUrl.pathname }`;\n  const extension = path.parse(pathname).ext;\n\n  const fileTypes = {\n    <span class="hljs-string">\'.ico\'</span>  : <span class="hljs-string">\'image/x-icon\'</span>,\n    <span class="hljs-string">\'.html\'</span> : <span class="hljs-string">\'text/html\'</span>,\n    <span class="hljs-string">\'.js\'</span>   : <span class="hljs-string">\'text/javascript\'</span>,\n    <span class="hljs-string">\'.json\'</span> : <span class="hljs-string">\'application/json\'</span>,\n    <span class="hljs-string">\'.css\'</span>  : <span class="hljs-string">\'text/css\'</span>,\n    <span class="hljs-string">\'.png\'</span>  : <span class="hljs-string">\'image/png\'</span>,\n    <span class="hljs-string">\'.jpg\'</span>  : <span class="hljs-string">\'image/jpeg\'</span>,\n    <span class="hljs-string">\'.wav\'</span>  : <span class="hljs-string">\'audio/wav\'</span>,\n    <span class="hljs-string">\'.mp3\'</span>  : <span class="hljs-string">\'audio/mpeg\'</span>,\n    <span class="hljs-string">\'.svg\'</span>  : <span class="hljs-string">\'image/svg+xml\'</span>,\n    <span class="hljs-string">\'.pdf\'</span>  : <span class="hljs-string">\'application/pdf\'</span>,\n    <span class="hljs-string">\'.doc\'</span>  : <span class="hljs-string">\'application/msword\'</span>\n  };\n\n  // Not static\n  <span class="hljs-keyword">if</span> (!fileTypes[extension]) {\n    relay.extensions.<span class="hljs-built_in">debug</span>(`${ request.url } is <span class="hljs-keyword">not</span> static`);\n    <span class="hljs-built_in">next</span>();\n    <span class="hljs-keyword">return</span>;\n  }\n\n  fs.exists(pathname, <span class="hljs-function"><span class="hljs-params">(exist)</span> =&gt;</span> {\n    <span class="hljs-keyword">if</span>(!exist) {\n      relay.extensions.<span class="hljs-built_in">debug</span>(`${ pathname } does <span class="hljs-keyword">not</span> exist on disk`);\n      response.end(<span class="hljs-string">\'404 - File not found\'</span>);\n      relay.exit();\n    } <span class="hljs-keyword">else</span> {\n      relay.extensions.<span class="hljs-built_in">debug</span>(`${ pathname } does exist loading it`);\n      // read file <span class="hljs-keyword">from</span> file system\n      fs.readFile(pathname, <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">error</span>, data)</span> =&gt;</span> {\n        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">error</span>){\n          relay.extensions.<span class="hljs-built_in">debug</span>(`File ${ pathname } <span class="hljs-keyword">not</span> found on disk`);\n          response.end(<span class="hljs-string">\'404 - File not found\'</span>);\n        } <span class="hljs-keyword">else</span> {\n          relay.extensions.<span class="hljs-built_in">debug</span>(<span class="hljs-string">\'sending back static file: \'</span> + pathname);\n          response.setHeader(<span class="hljs-string">\'Content-type\'</span>, fileTypes[extension] || <span class="hljs-string">\'text/plain\'</span> );\n          response.end(data);\n        }\n        relay.exit();\n      });\n    }\n  });\n}\n</code></pre><p>We will not going to much into detail on how this middleware works, it is pretty self explanatory. The only thing to notice is that we use <code>relay.exit()</code> after we are done responding to a static request. Read the <a href="/guide/update-and-middleware-stack">Update and middleware stack</a> section to find out why.</p>\n<p>Next: <a href="/guide/make-a-single-page-app">Turn your server side rendered page in to a single page app</a></p>\n\n        </section>\n    ','article'),a()};

},{}],12:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n        <section id="" data="lr-loaded">\n          <h1 id="hello-world">Hello world</h1>\n<p>The most simple and of course mandatory example is the hello-world example. In our case it will be a server only response which you can check in your browser. Open a browser tab and navigate to <code>http://localhost:8080</code>. This should show you a nice header with <em>Hello World</em>.</p>\n<blockquote>\n<p>Check the <a href="/guide/setup">setup and running the examples</a> to see how to start the webserver.</p>\n</blockquote>\n<h4 id="the-code">The code</h4>\n<p>Let&#39;s have a look at how the response has been generated.</p>\n<h5 id="hello-world-source-bootstrap-webserver-js">hello-world/source/bootstrap/webserver.js</h5>\n<pre><code><span class="hljs-keyword">const</span> protocol = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'http\'</span>);\n<span class="hljs-keyword">const</span> server   = protocol.createServer();\n<span class="hljs-keyword">const</span> router   = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-server-router\'</span>)(server);\n<span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-main\'</span>)(<span class="hljs-string">\'webserver\'</span>)\n  .extension(<span class="hljs-string">\'router\'</span>, router, <span class="hljs-literal">true</span>)\n  .middleware({\n    <span class="hljs-attr">response</span> : <span class="hljs-function">(<span class="hljs-params">next, relay, request, response</span>) =&gt;</span> {\n      response.end(<span class="hljs-string">\'&lt;h1&gt;Hello world&lt;/h1&gt;\'</span>);\n    }\n  })\n  .done(<span class="hljs-string">\'response\'</span>);\n\nserver.listen(<span class="hljs-number">8080</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'server running on localhost:8080\'</span>);\n});\n</code></pre><p>As you can see, it is a pretty straight forward process. First we add some standard packages and create the node server.</p>\n<p>The first thing that needs some explanation is the router package.</p>\n<pre><code>const router   = require(\'lr-server-router\')(<span class="hljs-name">server</span>)<span class="hljs-comment">;</span>\n</code></pre><p>The router package is a simple wrapper around the server request event and takes care of routing the request throught the core. As you can see it needs one argument, namely the server that you want to use.</p>\n<blockquote>\n<p>Lagoon road doesn&#39;t limit itself to the HTTP protocol. Using websockets, or maybe both together, <a href="/guide/writing-extensions">extensions</a> are the way to go.</p>\n</blockquote>\n<p>The next step is initializing the core and create a road object.</p>\n<pre><code><span class="hljs-function"><span class="hljs-title">require</span><span class="hljs-params">(<span class="hljs-string">\'lr-main\'</span>)</span><span class="hljs-params">(<span class="hljs-string">\'webserver\'</span>)</span></span>\n</code></pre><p>We intialize the core here with a single argument. The argument is the identifier for our environment. Each time you initialize the road you want to tell it the context of where we want to attach the middleware and extensions. In this case we want to run it as a web server so we use that as the identifier.</p>\n<blockquote>\n<p>The executing environment, in this case <code>webserver</code> will make more sense when we have more environments and start sharing code between them. We will look at that in the next examples.</p>\n</blockquote>\n<p>After we have initialized the road we want to attach our router as an extension.</p>\n<pre><code>.extension(<span class="hljs-string">\'router\'</span>, router, <span class="hljs-literal">true</span>)\n</code></pre><p>It is very simple to add an extension. Just give it an id, the first argument, add the package, the second argument, and you are done. In our case we have a third argument, a boolean. This tells the core to execute the middleware on initialization. This is typically for packages that can trigger updates, like a router, that receives request events.</p>\n<blockquote>\n<p>To learn more about extensions and execution on initialization read about writing <a href="/guide/writing-extensions">extensions</a></p>\n</blockquote>\n<p>Now that we added the router as an extension, we can actually receive request events. In order to act upon these events we need to add some middleware.</p>\n<pre><code>.middleware({\n  <span class="hljs-built_in">response</span> : (<span class="hljs-keyword">next</span>, relay, <span class="hljs-built_in">request</span>, <span class="hljs-built_in">response</span>) =&gt; {\n    <span class="hljs-built_in">response</span>.<span class="hljs-keyword">end</span>(<span class="hljs-comment">\'&lt;h1&gt;Hello world&lt;/h1&gt;\');</span>\n    <span class="hljs-keyword">next</span>();\n  }\n})\n</code></pre><p>As you can see the middleware method expects an object as argument. It is a flat, non nested object where you can assign all the middleware that you need. In our case that is a single one. The middleware might have an odd argument signature for people who are familiar with middleware. There is a good reason for this change which you can read about in the <a href="/faq">faq</a> section. The middlware is a simple response that sends back the html that we want to show on the client.</p>\n<blockquote>\n<p>Always call the <code>next</code> method, even in the last middleware that you add. Read why in the <a href="/guide/update-and-middleware-stack">update and middleware stack</a></p>\n</blockquote>\n<p>To act upon an event that might be triggered by the router, we need to add some listeners to the road. There are a couple of ways to do this. There is <code>run</code>, <code>noMatch</code>, <code>error</code> and <code>done</code>. The first three we will see in the following examples in this guide. For now we use the <code>done</code> hook. </p>\n<pre><code><span class="hljs-selector-class">.done</span>(<span class="hljs-string">\'response\'</span>)\n</code></pre><p>The <code>done</code> hook is the last middleware that gets added to the stack that needs to be executed. It is the perfect place to respond to requests and as we will see later, render html. As you can see, the method takes a single argument, the middleware id. The middleware id is the key in the object that we specified in the middelware method. Now we have added a listener to the road, so whenever an update happends, regardless of the path it will go through the <code>done</code> method and in our case respond with a nice &#39;hello world&#39;.</p>\n<p>Now that we have got our feet wet in the warm calm waters of Lagoon road it is time to add a server side renderer to send some proper html back.</p>\n<p>Next: <a href="/guide/adding-server-side-renderer">Adding the server side renderer</a></p>\n\n        </section>\n    ','article'),a()};

},{}],13:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n    <section id="guide" data-lr="loaded">\n      <h1>Guide</h1>\n      <p>Select on of the following guides</p>\n      <ul class="submenu">\n        <li><a href="/guide/setup">Setup and running the examples</a></li>\n        <li><a href="/guide/hello-world">Hello world</a></li>\n        <li><a href="/guide/adding-server-side-renderer">Adding the server side renderer</a></li>\n        <li><a href="/guide/handling-static-content">Handling static content</a></li>\n        <li><a href="/guide/make-a-single-page-app">Turn your server side rendered page into a single page app</a></li>\n        <li><a href="/guide/working-with-dom-events">Working with DOM events</a></li>\n        <li><a href="/guide/adding-url-parameters-via-a-parser">Adding url parameters via a parser</a></li>\n        <li><a href="/guide/update-and-middleware-stack">Update and middleware stack</a></li>\n        <li><a href="/guide/writing-extensions">Writing extensions</a></li>\n        <li><a href="/guide/writing-parsers">Writing parsers</a></li>\n      </ul>\n    </section>\n  ','article'),a()};

},{}],14:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n        <section id="" data="lr-loaded">\n          <h1 id="make-a-single-page-app">Make a single page app</h1>\n<p>Now that we have all the server side stuff in place it is time to spice things up a bit and show you where Lagoon road really shines, sharing code between environments.</p>\n<h5 id="lr-examples-make-a-single-page-app-source-webserver-js">lr-examples/make-a-single-page-app/source/webserver.js</h5>\n<pre><code><span class="hljs-keyword">const</span> protocol = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'http\'</span>);\n<span class="hljs-keyword">const</span> server   = protocol.createServer();\n<span class="hljs-keyword">const</span> router   = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-server-router\'</span>)(server);\n<span class="hljs-keyword">const</span> renderer = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-server-renderer\'</span>)();\n<span class="hljs-keyword">const</span> road     = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-main\'</span>)(<span class="hljs-string">\'webserver\'</span>)\n  .extension(<span class="hljs-string">\'router\'</span>, router, <span class="hljs-literal">true</span>)\n  .extension(<span class="hljs-string">\'renderer\'</span>, renderer)\n  .middleware({\n    <span class="hljs-string">\'layouts.default\'</span> : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/layouts/default\'</span>),\n    <span class="hljs-attr">response</span>          : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/response\'</span>),\n    <span class="hljs-attr">statics</span>           : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/statics\'</span>),\n  });\n\n<span class="hljs-built_in">require</span>(<span class="hljs-string">\'./road\'</span>)(road);\n\nserver.listen(<span class="hljs-number">8080</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'server running on localhost:8080\'</span>);\n});\n</code></pre><p>The webserver in basically the same as in the server side example, except that we removed the middleware that we want to share between enviroments. Only the middleware that is exclusive for the webserver is added in this file.</p>\n<p>After we have setup the road, we pass it down to a new file, <code>require(&#39;./road&#39;)</code>.</p>\n<pre><code><span class="hljs-selector-tag">require</span>(<span class="hljs-string">\'./road\'</span>)(road);\n</code></pre><p>This is the file that we will use for all the shared code between environments.</p>\n<h5 id="lr-examples-make-a-single-page-app-source-client-js">lr-examples/make-a-single-page-app/source/client.js</h5>\n<pre><code><span class="hljs-keyword">const</span> router   = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-client-router\'</span>);\n<span class="hljs-keyword">const</span> renderer = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-client-renderer\'</span>);\n<span class="hljs-keyword">const</span> road     = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-main\'</span>)(<span class="hljs-string">\'client\'</span>)\n  .extension(<span class="hljs-string">\'router\'</span>, router, <span class="hljs-literal">true</span>)\n  .extension(<span class="hljs-string">\'renderer\'</span>, renderer, <span class="hljs-literal">true</span>);\n\n<span class="hljs-built_in">require</span>(<span class="hljs-string">\'./road\'</span>)(road);\n</code></pre><p>As you can see the client side code looks very similar to the web server code, the packages are different but are hooked in under the exact same name, this allows us to use the same middleware for both client and server. Specific client side middleware can be hooked up in the <code>client.js</code> file.</p>\n<h5 id="lr-examples-make-a-single-page-app-source-road-js">lr-examples/make-a-single-page-app/source/road.js</h5>\n<pre><code><span class="hljs-keyword">const</span> debug = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../extensions/debug\'</span>);\n\n<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">road</span> =&gt;</span> {\n  road\n    .extension(<span class="hljs-string">\'debug\'</span>, debug)\n    .middleware({\n      <span class="hljs-attr">debug</span>                   : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/debug\'</span>),\n      <span class="hljs-string">\'components.navigation\'</span> : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/components/navigation\'</span>),\n      <span class="hljs-string">\'components.home\'</span>       : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/components/home\'</span>),\n      <span class="hljs-string">\'components.contact\'</span>    : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/components/contact\'</span>)\n    })\n    .where(<span class="hljs-string">\'webserver\'</span>)\n      .run(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'debug\'</span>)\n      .run(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'statics\'</span>)\n      .run(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'layouts.default\'</span>)\n    .where(<span class="hljs-string">\'webserver\'</span>, <span class="hljs-string">\'client\'</span>)\n      .run(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'components.navigation\'</span>)\n      .run(<span class="hljs-string">\'/\'</span>, <span class="hljs-string">\'components.home\'</span>)\n      .run(<span class="hljs-string">\'/contact\'</span>, <span class="hljs-string">\'components.contact\'</span>)\n      .done(<span class="hljs-string">\'response\'</span>);\n}\n</code></pre><p>The road file is the place where we add all the stuff that needs to be shared between our environments. This is not limited to the client and web server. If you have an API server you can add the listeners here too. You have a single file were you can find all the paths that your app is using. It becomes very easy to figure out the flow of your app.</p>\n<p>You can see that we use a new method</p>\n<pre><code>.<span class="hljs-keyword">where</span>(<span class="hljs-string">\'webserver\'</span>)\n</code></pre><p>This method sets the context for all the following methods, so the core knows that the <code>run</code> method belongs to the webserver. Sharing methods between environments becomes a breeze, just add all the environments that need to share code and you are done.</p>\n<pre><code>.<span class="hljs-keyword">where</span>(<span class="hljs-string">\'webserver\'</span>, <span class="hljs-string">\'client\'</span>)\n</code></pre><p>Next: <a href="/guide/working-with-dom-events">Working with DOM events</a></p>\n\n        </section>\n    ','article'),a()};

},{}],15:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n        <section id="" data="lr-loaded">\n          <h1 id="installing-lagoon-road">Installing Lagoon Road</h1>\n<p>Like any other npm package you can just run</p>\n<pre><code>npm <span class="hljs-selector-tag">i</span> --save lr-main\n</code></pre><blockquote>\n<p>All the package names for the supplied packages can be found in the <a href="/reference">reference overview</a>.</p>\n</blockquote>\n<h2 id="following-the-examples">Following the examples</h2>\n<p>The easiest way to follow the examples is just to clone the lr-examples repo. This repo contains some build tools that help generating client side js code. So you don&#39;t have to manually setup Babel, Browserify and the likes.</p>\n<p>If you feel more adventurous, you can just checkout the packages you need and glance over the examples, it will show you how to use the road on client and server among some other common scenarios.</p>\n<p>To clone the repo just go to your preferred directory and run one of the two following commands:</p>\n<p><strong>SSH</strong>  </p>\n<pre><code>git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:lagoon-road/lr-examples.git\n</code></pre><p><strong>HTTPS</strong>  </p>\n<pre><code>git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/lagoon-road/lr-examples.git\n</code></pre><p>In the repo you can find folders for all the examples. Most folders will contain a <code>source</code> folder and a <code>public</code> folder. The <code>source</code> folder is where we write our code and it is also the folder which the node server will use to serve its responses.</p>\n<p>The <code>public</code> folder is the folder where the generated client side code will be saved. There are some <code>scripts</code> in the <code>package.json</code> file that help you do that.</p>\n<pre><code>npm <span class="hljs-keyword">run</span><span class="bash"> watch</span>\n</code></pre><p>This command will build the client side code and watches file changes.</p>\n<p>To start the server you can simply run</p>\n<pre><code>npm <span class="hljs-keyword">run</span><span class="bash"> serve</span>\n</code></pre><p>Before you can run the code, you need to install all the npm packages, to do so run the command below, you only have to do this once.</p>\n<pre><code>npm <span class="hljs-keyword">install</span>\n</code></pre><blockquote>\n<p>The Lagoon road packages contain ES6 code, for the client it will be transpiled and browserified. Server side code isn&#39;t transpiled so either install the latest node version or transpile the code to run it in an older node version.</p>\n</blockquote>\n<h4 id="next-hello-world-guide-hello-world-">Next: <a href="/guide/hello-world">Hello-world</a></h4>\n\n        </section>\n    ','article'),a()};

},{}],16:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n        <section id="" data="lr-loaded">\n          <h1 id="update-and-middleware-stack">Update and middleware stack</h1>\n<p>As you have seen by now in the examples within this guide, there is a common pattern that we follow in Lagoon road. We listen to update events and match them with the <code>updateType</code> and <code>matchValue</code>. So what does happen in the core whenever a update event is fired?</p>\n<p>Each time the update event is triggered the core looks up all the middleware that matches that specific update. If it can find matches for the update it will add the middleware that is added via the <code>run</code> method to the stack. If there is no match, <code>noMatch</code> will be added to the stack.</p>\n<p>Next the <code>done</code> middleware will be concatenated with the stack that just has been created. Once we have a final array of all the middleware that we need, we start to thunkify the middleware functions to get the typical <code>next()</code> function. Everytime the <code>next()</code> function is called it will merge the <code>relay</code> data with the data that already exist and a check is performed to see if the middleware signature should be traditional or not.</p>\n<p>It can happen that during the execution of the stack an error occurs within a middleware function. If this is the case then the stack will be cleared and the <code>error</code> middleware will be added together with the <code>done</code> middleware.</p>\n<p>Once all the middleware functions on the stack have been executed the core waits for new update events to come in...</p>\n<p>In an ideal world the stack is completely finished before a new update event is triggered. In the real world this is not the case. It can happen that a middleware function in the stack is executing and a new update event is triggered. This can cause all sorts of nasty race conditions.</p>\n<p>To mitigate this problem, Lagoon road not just stacks its middleware, but also the update events. So every time an update event happens and the stack is still processing its middleware we wait before triggering a new update event and call that middleware. No more race conditions so you can be sure that, if you want to do some state management, your data is correct.</p>\n<p>Because there might be a multitude of update events being added to the stack the last call in a middleware stack is not persee the last middleware function to be called. Therefore <strong>you must always add the <code>next()</code> method in each middleware function.</strong> The last <code>next()</code> function tells the core to handle stacked update events that might be waiting to be executed.</p>\n<p>Having all the data synchronized is nice, but there are cases where there is no dependency between update events, so they could run in parallel to speed up execution. This is the case when you want to serve static content. This is another reason to start using a reverse proxy to take care of your statics.</p>\n<p>Finally there are cases where a middleware function does some actions which result in the fact that all the following middleware should not be executed. You want to tell the core that you are done with the current middleware stack so that potential new update stack records can be set in motion. This scenario happens in our statics example. We call the <code>response.end</code> method when a file is considered a static. In that case we don&#39;t want to go through the rest of the middleware stack because we have already send back the response. In order to tell the core that we want to terminate the current middleware stack we can call the <code>relay.exit()</code> method.</p>\n<blockquote>\n<p>It is good practice to try and do your responses in the <code>.done()</code> method and avoid using the <code>.exit()</code> method when possible. It has mainly been added to do stuff like static middleware, but again, better do that with a reverse proxy.</p>\n</blockquote>\n<p>Next: <a href="/guide/writing-extensions">Writing extensions</a></p>\n\n        </section>\n    ','article'),a()};

},{}],17:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n        <section id="" data="lr-loaded">\n          <h1 id="working-with-dom-events">Working with DOM events</h1>\n<p>In this guide we will do a simple <code>console.log</code> from our event middleware that will show you that the DOM is ready to be accessed.</p>\n<h5 id="working-with-dom-events-source-middleware-events-navigation-js">working-with-dom-events/source/middleware/events/navigation.js</h5>\n<pre><code><span class="hljs-built_in">module</span>.exports = (next, relay) =&gt; {\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`There</span> are <span class="hljs-string">${</span> <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">\'nav\').children.length</span> <span class="hljs-string">}</span> menu items<span class="hljs-string">`);</span>\n  next();\n}\n</code></pre><p>Just a regular middleware function that should give is the number of menu items.</p>\n<h5 id="working-with-dom-events-source-middleware-bootstrap-client-js">working-with-dom-events/source/middleware/bootstrap/client.js</h5>\n<pre><code><span class="hljs-keyword">const</span> router   = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-client-router\'</span>);\n<span class="hljs-keyword">const</span> renderer = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-client-renderer\'</span>);\n<span class="hljs-keyword">const</span> road     = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-main\'</span>)(<span class="hljs-string">\'client\'</span>)\n  .extension(<span class="hljs-string">\'router\'</span>, router, <span class="hljs-literal">true</span>)\n  .extension(<span class="hljs-string">\'renderer\'</span>, renderer, <span class="hljs-literal">true</span>)\n  .middleware({\n    <span class="hljs-string">\'events.navigation\'</span> : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/events/navigation\'</span>)\n  });\n\n<span class="hljs-built_in">require</span>(<span class="hljs-string">\'./road\'</span>)(road);\n</code></pre><p>We have added the middleware to the client, this is obviously because it should only be used on the clientside.</p>\n<h5 id="working-with-dom-events-source-middleware-bootstrap-road-js">working-with-dom-events/source/middleware/bootstrap/road.js</h5>\n<pre><code><span class="hljs-keyword">const</span> debug = require(<span class="hljs-string">\'../extensions/debug\'</span>);\n\n<span class="hljs-keyword">module</span>.exports = road =&gt; {\n  road\n    .extension(<span class="hljs-string">\'debug\'</span>, debug)\n    .middleware({\n      debug                   : require(<span class="hljs-string">\'../middleware/debug\'</span>),\n      <span class="hljs-string">\'components.navigation\'</span> : require(<span class="hljs-string">\'../middleware/components/navigation\'</span>),\n      <span class="hljs-string">\'components.home\'</span>       : require(<span class="hljs-string">\'../middleware/components/home\'</span>),\n      <span class="hljs-string">\'components.contact\'</span>    : require(<span class="hljs-string">\'../middleware/components/contact\'</span>)\n    })\n    .where(<span class="hljs-string">\'webserver\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'debug\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'statics\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'layouts.default\'</span>)\n    .where(<span class="hljs-string">\'client\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'events.navigation\'</span>, <span class="hljs-string">\'navigationLoaded\'</span>)\n    .where(<span class="hljs-string">\'webserver\'</span>, <span class="hljs-string">\'client\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'components.navigation\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'/\'</span>, <span class="hljs-string">\'components.home\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'/contact\'</span>, <span class="hljs-string">\'components.contact\'</span>)\n    .where(<span class="hljs-string">\'webserver\'</span>)\n      .done(<span class="hljs-string">\'response\'</span>);\n}\n</code></pre><p>We added a new hook to the road</p>\n<pre><code>.<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'events.navigation\'</span>, <span class="hljs-string">\'navigationLoaded\'</span>)\n</code></pre><p>As you can see we added a custom <code>updateType</code>. This is an update type that the client side router triggers whenever a file has been added to the DOM. How it is constructed we will see after we have looked at the navigation template middleware.</p>\n<h5 id="working-with-dom-events-source-middleware-middleware-components-navigation-js">working-with-dom-events/source/middleware/middleware/components/navigation.js</h5>\n<pre><code>module.exports = (next, relay, request) =&gt; {\n  relay.extensions.debug(\'Rendering component navigation: \' + request.url);\n  relay.extensions.renderer.render(\'\n    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"navigation"</span> <span class="hljs-attr">data-lr</span>=<span class="hljs-string">"loaded"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/"</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/contact"</span>&gt;</span>Contact<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n  \', \'nav\');\n  next();\n}\n</code></pre><p>We added an <code>id</code> and a <code>data-lr</code> attribute. Together they are responsible for the DOM added update event. The <code>id</code> is just for the identification of the component. The <code>data-lr</code> attribute adds a type to the component. You can create several templates for the same component. One for when data is loading, one for when data is loaded and you could add one when an error occurs. The <code>data-lr</code> value will be passed through as the <code>updateType</code> together with the id in a camelcased form. So in this example it will be <code>navigationLoaded</code>.</p>\n<p>Next: <a href="/guide/adding-url-parameters-via-a-parser">Adding url parameters via a parser</a></p>\n\n        </section>\n    ','article'),a()};

},{}],18:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n        <section id="" data="lr-loaded">\n          <h1 id="working-with-data">Working with data</h1>\n<p>In our last big example we will put everything together and add data loading to the mix.</p>\n<h5 id="working-with-data-source-bootstrap-client-js">working-with-data/source/bootstrap/client.js</h5>\n<pre><code><span class="hljs-built_in">require</span>(<span class="hljs-string">"babel-polyfill"</span>);\n<span class="hljs-keyword">const</span> router     = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-client-router\'</span>);\n<span class="hljs-keyword">const</span> renderer   = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-client-renderer\'</span>);\n<span class="hljs-keyword">const</span> httpClient = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../extensions/httpClient\'</span>)(<span class="hljs-string">\'http://eol.org/api/\'</span>);\n<span class="hljs-keyword">const</span> road       = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-main\'</span>)(<span class="hljs-string">\'client\'</span>)\n  .extension(<span class="hljs-string">\'router\'</span>, router, <span class="hljs-literal">true</span>)\n  .extension(<span class="hljs-string">\'renderer\'</span>, renderer, <span class="hljs-literal">true</span>)\n  .extension(<span class="hljs-string">\'httpClient\'</span>, httpClient)\n  .middleware({\n    <span class="hljs-string">\'events.navigation\'</span> : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/events/navigation\'</span>),\n    <span class="hljs-string">\'events.home\'</span>       : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/events/home\'</span>)\n  });\n\n<span class="hljs-built_in">require</span>(<span class="hljs-string">\'./road\'</span>)(road);\n</code></pre><p>We made two changes to this file</p>\n<pre><code>require(<span class="hljs-string">"babel-polyfill"</span>)<span class="hljs-comment">;</span>\n</code></pre><p>We added the polyfill so we can use async and await on the client. We will see in the data middleware in a moment how. Furthermore we added the <code>httpClient</code> middleware to the road. We added this also to the <code>webserver.js</code> file.</p>\n<h5 id="working-with-data-source-middleware-data-about-js">working-with-data/source/middleware/data/about.js</h5>\n<pre><code>module.exports = async function(next, relay) {\n  const path  = \'pages/<span class="hljs-number">1.0</span>.json?id=<span class="hljs-number">1048601</span>&amp;details=true\';\n  const data  = await relay.extensions.httpClient.get(path);\n  const about = JSON.parse(data.text).dataObjects.shift().description;\n  const <span class="hljs-keyword">state</span> = Object.assign({}, relay.<span class="hljs-keyword">state</span> ? relay.<span class="hljs-keyword">state</span> : {}, { about });\n  next({ <span class="hljs-keyword">state</span> });\n}\n</code></pre><p>We added a new middleware function that loads data from Encyclopedia of Life about the Masked Booby, the bird in the logo, for the people who are not an ornithologist by profession. As you can see it is an <code>async function</code> so we can wait until the data is loaded. There is no need for a <code>try...catch</code> block because any error will be catched by the core and trigger the error middleware if available, otherwise it with output the error to the console. The error will be available at <code>relay.error</code>.</p>\n<p>The result will be passed to the next middleware function as a <code>state</code> property on the relay object, so we can use it in the template.</p>\n<h5 id="working-with-data-source-middleware-components-about-loading-js">working-with-data/source/middleware/components/about/loading.js</h5>\n<pre><code><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">next</span>, relay)</span> =&gt;</span> {\n  relay.extensions.renderer.render(<span class="hljs-string">\'\n    &lt;section id="about" data-lr="loading"&gt;Loading...&lt;/section&gt;\n  \'</span>, <span class="hljs-string">\'.content\'</span>);\n  <span class="hljs-built_in">next</span>();\n}\n</code></pre><p>We added a loading template for when the data is not available yet.</p>\n<h5 id="working-with-data-source-middleware-components-about-loaded-js">working-with-data/source/middleware/components/about/loaded.js</h5>\n<pre><code>module.exports = (next, relay, request) =&gt; {\n  relay.extensions.renderer.render(\'\n    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"about"</span> <span class="hljs-attr">data-lr</span>=<span class="hljs-string">"loaded"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>About the masked booby<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>${ relay.state.about }<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>\n  \', \'.content\');\n  next();\n}\n</code></pre><p>Once the data is available we will render the <code>loaded</code> template with the data.</p>\n<h5 id="working-with-data-source-bootstrap-road-js">working-with-data/source/bootstrap/road.js</h5>\n<pre><code><span class="hljs-keyword">module</span>.exports = road =&gt; {\n  road\n    .middleware({\n      <span class="hljs-string">\'data.about\'</span>                   : require(<span class="hljs-string">\'../middleware/data/about\'</span>),\n      <span class="hljs-string">\'data.home\'</span>                    : require(<span class="hljs-string">\'../middleware/data/home\'</span>),\n      <span class="hljs-string">\'components.navigation.loaded\'</span> : require(<span class="hljs-string">\'../middleware/components/navigation/loaded\'</span>),\n      <span class="hljs-string">\'components.home.loaded\'</span>       : require(<span class="hljs-string">\'../middleware/components/home/loaded\'</span>),\n      <span class="hljs-string">\'components.home.loading\'</span>      : require(<span class="hljs-string">\'../middleware/components/home/loading\'</span>),\n      <span class="hljs-string">\'components.about.loaded\'</span>      : require(<span class="hljs-string">\'../middleware/components/about/loaded\'</span>),\n      <span class="hljs-string">\'components.about.loading\'</span>     : require(<span class="hljs-string">\'../middleware/components/about/loading\'</span>),\n    })\n    .where(<span class="hljs-string">\'webserver\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'statics\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'layouts.default\'</span>)\n    .where(<span class="hljs-string">\'client\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'events.navigation\'</span>, <span class="hljs-string">\'navigationLoaded\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'/\'</span>, <span class="hljs-string">\'events.home\'</span>, <span class="hljs-string">\'homeLoaded\'</span>)\n    .where(<span class="hljs-string">\'webserver\'</span>, <span class="hljs-string">\'client\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'updateValue\'</span>, <span class="hljs-string">\'log\'</span>, <span class="hljs-string">\'updateType\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'components.navigation.loaded\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'/\'</span>, <span class="hljs-string">\'components.home.loaded\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'/\'</span>, <span class="hljs-string">\'components.home.loading\'</span>, <span class="hljs-string">\'data\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'/\'</span>, <span class="hljs-string">\'data.home\'</span>, <span class="hljs-string">\'data\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'/\'</span>, <span class="hljs-string">\'components.home.loaded\'</span>, <span class="hljs-string">\'data\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'/error\'</span>, <span class="hljs-string">\'fail\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'/about\'</span>, <span class="hljs-string">\'components.about.loading\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'/about\'</span>, <span class="hljs-string">\'data.about\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'/about\'</span>, <span class="hljs-string">\'components.about.loaded\'</span>)\n      .error(<span class="hljs-string">\'components.about.error\'</span>)\n    .where(<span class="hljs-string">\'webserver\'</span>)\n      .done(<span class="hljs-string">\'response\'</span>);\n}\n</code></pre><p>This is the <code>road.js</code> file and the code we will focus on is the following</p>\n<pre><code>.<span class="hljs-built_in">run</span>(\'/<span class="hljs-keyword">about</span>\', \'components.<span class="hljs-keyword">about</span>.loading\')\n.<span class="hljs-built_in">run</span>(\'/<span class="hljs-keyword">about</span>\', \'data.<span class="hljs-keyword">about</span>\')\n.<span class="hljs-built_in">run</span>(\'/<span class="hljs-keyword">about</span>\', \'components.<span class="hljs-keyword">about</span>.loaded\')\n</code></pre><p>We have the templates added in the right order with the data loading middleware right in between. That is it, data loading made easy.</p>\n<h3 id="loading-data-on-a-click">Loading data on a click</h3>\n<p>There is also an example in the code how to load data on a click, which is another very common use case. </p>\n<pre><code><span class="hljs-built_in">module</span>.exports = <span class="hljs-function">(<span class="hljs-params">next, relay</span>) =&gt;</span> {\n  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">\'button\'</span>).addEventListener(<span class="hljs-string">\'click\'</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n    event.preventDefault();\n    relay.update({ matchValue : <span class="hljs-built_in">window</span>.location.pathname, updateType : <span class="hljs-string">\'data\'</span> });\n  });\n  next();\n}\n</code></pre><p>Whenever you need to load data on click you just call the <code>update</code> method in the event middleware, call it with the route that you are on and a unique <code>updateType</code>. It will trigger the right middleware again as you can see in the <code>road.js</code> file. It basically does the exact same thing as loading the data on a page load.</p>\n<blockquote>\n<p>Data is now loaded on every page request, that is obviously not wath you normally want. It is easy to add a check if <code>relay.state.about</code> already exists and if not load the data. Just make sure you have set the <code>resetUpdateCycle</code> to <code>false</code> so the relay data stays intact after an update event</p>\n</blockquote>\n<p>Next: <a href="/guide/writing-parsers">Writing a parser</a></p>\n\n        </section>\n    ','article'),a()};

},{}],19:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n        <section id="" data="lr-loaded">\n          <h1 id="writing-extensions">Writing extensions</h1>\n<p>We already looked at a simple debug extension in the <a href="adding-server-side-renderer">adding server side renderer</a> guide. It is time to look at two more examples.</p>\n<pre><code><span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'superagent\'</span>);\n\n<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">domain</span> =&gt;</span> {\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-keyword">get</span>(path) {\n      <span class="hljs-keyword">return</span> superagent.get(domain + path).type(<span class="hljs-string">\'json\'</span>);\n    }\n  }\n}\n</code></pre><p>The first extension is for loading data. As you can see we create a function that expects a domain as argument. The reason for this is that if you are running the web server and API server on the same physical server you want to use a localhost address, whereas the client obviously needs a public domain.</p>\n<p>The returned object just has one method, <code>get</code>. We pass in the path and <code>superagent</code> will return a promise. We will use this extension in the next guide and see how we go about working with async calls.</p>\n<p>The next extension will be one that triggers an update event.</p>\n<pre><code>module.exports = <span class="hljs-keyword">update</span> =&gt; {\n  return {\n    go() {\n      update({ matchValue : <span class="hljs-string">\'updateValue\'</span>, updateType : <span class="hljs-string">\'updateType\'</span>});\n    }\n  }\n}\n</code></pre><p>The extension looks very similar to the first one. It again has a single argument, this time it will be a function that has been passed in. We use the update function in the returned object within the <code>go</code> method.</p>\n<p>Whenever you want to trigger the <code>update</code> function you pass in an option object with a <code>matchValue</code> and <code>updateType</code>. You can add optional parameters from the second argument on. They will be added to the middleware function like <code>request</code> and <code>response</code>.</p>\n<p>To get an instance of the update function we have to look at the way we add the extension to the road.</p>\n<pre><code><span class="hljs-attribute">road</span>\n    .extension(<span class="hljs-string">\'router\'</span>, router, <span class="hljs-literal">true</span>);\n</code></pre><p>The third parameter here is important, it will call the extension whenever it is added to the core. It will make the <code>update</code> function available to the extension.</p>\n<blockquote>\n<p>When you have update event triggering extensions and you need to set some parameters, you can just wrap it in another function like the first example. Just return a curried function, all rise to functional programming!</p>\n</blockquote>\n<p>Next: <a href="/guide/working-with-data">Working with data</a></p>\n\n        </section>\n    ','article'),a()};

},{}],20:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n        <section id="" data="lr-loaded">\n          <h1 id="writing-parsers">Writing parsers</h1>\n<p>There might be scenarios where you need some custom parsers for the <code>matchValue</code>. This guide will show you how to.</p>\n<pre><code><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-keyword">return</span> {\n        add(matchValue) {},\n        parse(matchValue) {}\n    }\n}\n</code></pre><p>A parser needs to return an object with two methods. <code>add</code> and <code>parse</code>. Whenever you add middleware via the <code>run</code> function the <code>add</code> method will be called and you can handle the given <code>matchValue</code> and store it in you parser. </p>\n<p>When later on the update event is been called the <code>matchValue</code> will go to the <code>parse</code> method. The parse method has to return an object. with the following signature.</p>\n<pre><code>{ <span class="hljs-attribute">path </span>: <span class="hljs-string">\'stringValue\'</span>, parameters : {} }\n</code></pre><p>The <code>path</code> property should be the value that should be the final <code>matchValue</code> that you want to match on in the <code>run</code> method. Parameters is an object with all the dynamic parts that you have taken from the <code>matchValue</code> that came from the update function.</p>\n\n        </section>\n    ','article'),a()};

},{}],21:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n    <section id="home" data-lr="loaded">\n      <div class="logo-text">\n        <h1>Lagoon road <span>Laid back webapps</span></h1>\n      </div>\n      <hr>\n      <p class="standout">Lagoon road helps you build webapps. It is not as low level as writing Javascript from scratch and it is not as high level as frameworks that can limit your flexibility. It sits right in the middle. It helps you to give structure to your app, lets you plug and play any package you like and doesn\'t get in the way when you write code the way you like. Lagoon road is laid back...</p>\n      <p>In Lagoon road, we turn everything in to middleware. Routing, templating, you name it. All this middleware is connected to a single object, which we call the <em>road</em>. You can picture it as a single road on an island. You can never get lost, it is either left or right. In Lagoon road it is even simpeler, it is a one way street.</p>\n      <p>Everything on the road is used by all environments that you are running, a web server, an API server, the client or even your Raspberry Pie/Aurdino and mobile device can be hooked up. Because of this it becomes a breeze to share code among these environments and still keep everything DRY. Sharing routes between client and a web server, have login checks for the API server and web server, sharing code is how Lagoon road works best.</p>\n      <p>Lagoon road is not a monolithic framework that does everything out of the box. The core, the only mandatory package is about 200 lines of code. You can add extensions (regular npm packages) to mold it in a system that works for you or your team. You remain in control over how you work and code.</p>\n      <section class="highlight">\n        <h2>Where from here?</h2>\n        <p>\n          <a href="/guide" class="pure-button">Examples in the <strong>guide</strong></a>\n          <a href="/reference" class="pure-button">Details in the <strong>reference</strong></a>\n          <a href="/faq" class="pure-button">Answers in the <strong>FAQ</strong></a>\n        </p>\n      </section>\n      <h2>Some <span class="laid-back">laid back</span> features of lagoon road</h2>\n      <ul class="features">\n        <li><span>1</span>It is modular, don\'t like a package, switch it for something else, it is all just npm packages</li>\n        <li><span>2</span>Websockets, HTTP(2), you can switch protocols without having to change the way you build your app</li>\n        <li><span>3</span>Plug in any store you like, you are not tied down to a single choice, you can even run multiple different ones next to each other</li>\n        <li><span>4</span>Share code between environments and keep it organized, even when you scale up</li>\n        <li><span>5</span>Want to hook up a Raspberry Pie or Arduino, sure thing, you can check for changes on sensory output and feed it straight into an API server, web server or straight to the browser</li>\n        <li><span>6</span>You know how middleware works? You are up and running for Lagoon road, no endless docs you have to plow through</li>\n      </ul>\n    </section>\n  ','article'),a()};

},{}],22:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n\t\t<ul id="navigation" data-lr="loaded">\n\t\t  <li><a href="/">Home</a></li>\n\t\t  <li><a href="/guide">Guide</a></li>\n\t\t  <li><a href="/reference">Reference</a></li>\n\t\t  <li><a href="/faq">Faq</a></li>\n\t\t</ul>\n\t','nav'),a()};

},{}],23:[function(require,module,exports){
'use strict';module.exports=function(a,b,c){b.extensions.renderer.render('\n    <section id="noMatch" data-lr="loaded">\n      <h1>404 - Page not found</h1>\n      <pre>\n        Oh my, '+c.url+' could not be found\n      </pre>\n    </section>\n  ','article'),a()};

},{}],24:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n    <section id="reference" data-lr="loaded">\n      <h1>Reference</h1>\n      <p>Although Lagoon road needs only a single package to be up and running, namely lr-main, it comes with additional packages that make it easy to do some common tasks, like routing and rendering.</p>\n      <ul class="submenu">\n        <li><a href="/reference/lr-main">lr-main</a></li>\n        <li><a href="/reference/lr-server-router">lr-server-router</a></li>\n        <li><a href="/reference/lr-server-renderer">lr-server-renderer</a></li>\n        <li><a href="/reference/lr-client-router">lr-client-router</a></li>\n        <li><a href="/reference/lr-client-renderer">lr-client-renderer</a></li>\n        <li><a href="/reference/lr-url-parser">lr-url-parser</a></li>\n      </ul>\n    </section>\n  ','article'),a()};

},{}],25:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n        <section id="" data="lr-loaded">\n          <h1 id="lr-client-renderer-reference">lr-client-renderer reference</h1>\n<p>A Lagoon road extension that gives you renderer functionality on the client. This renderer does quick replacement and doesn&#39;t do virtual dom html difference changes. It should suffice for about 95% of all cases. When you start working more with a websocket pub/sub system you might want to consider writing your own renderer or use a virtual dom approach so user input will not get replaced on dom updates. Read more about writing extensions in the <a href="/guide">guide</a>.</p>\n<blockquote>\n<p>The client side renderer sends out update events whenever a component has been added to the DOM. See the <a href="/guide/working-with-dom-events">guide</a> to understand how to implement this.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Information</th>\n<th>-</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Code coverage</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Repo link</td>\n<td><a href="https://github.com/lagoon-road/lr-client-renderer">lr-client-renderer</a></td>\n</tr>\n<tr>\n<td>Dependencies</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Size (Browserify, Babel and Gzip)</td>\n<td>851 bytes</td>\n</tr>\n<tr>\n<td>Version</td>\n<td>1.0.0</td>\n</tr>\n<tr>\n<td>License</td>\n<td>MIT</td>\n</tr>\n<tr>\n<td>Usage</td>\n<td><a href="/guide">guide</a></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id="adding-the-extension-to-lagoon-road">Adding the extension to lagoon road</h3>\n<pre><code><span class="hljs-keyword">const</span> router   = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-client-renderer\'</span>);\n<span class="hljs-keyword">const</span> road     = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-main\'</span>)(<span class="hljs-string">\'client\'</span>);\nroad\n  .extension(<span class="hljs-string">\'renderer\'</span>, renderer, <span class="hljs-literal">true</span>);\n</code></pre><hr>\n<h3 id="renderer-render-html-placeholder-">renderer.render(html, placeholder)</h3>\n<pre><code><span class="hljs-keyword">renderer</span>.<span class="hljs-keyword">render</span>(<span class="hljs-string">\'&lt;section&gt;...&lt;/section&gt;\'</span>, <span class="hljs-string">\'.placeholderName\'</span>);\n</code></pre><p><em>Add component to the template.</em></p>\n<p><strong>html:string</strong><br>The components html that you want to load.</p>\n<p><strong>placeholder:string</strong><br>A html selector that should be the parent of the html you want to add. The contents of the placeholder will be replaced with the new html.</p>\n\n        </section>\n    ','article'),a()};

},{}],26:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n        <section id="" data="lr-loaded">\n          <h1 id="lr-client-router-reference">lr-client-router reference</h1>\n<p>A Lagoon road extension that gives you route functionality on the client.</p>\n<table>\n<thead>\n<tr>\n<th>Information</th>\n<th>-</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Code coverage</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Repo link</td>\n<td><a href="https://github.com/lagoon-road/lr-client-router">lr-client-router</a></td>\n</tr>\n<tr>\n<td>Dependencies</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Size (Browserify, Babel and Gzip)</td>\n<td>632 bytes</td>\n</tr>\n<tr>\n<td>Version</td>\n<td>1.0.0</td>\n</tr>\n<tr>\n<td>License</td>\n<td>MIT</td>\n</tr>\n<tr>\n<td>Usage</td>\n<td><a href="/guide">guide</a></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id="adding-the-extension-to-lagoon-road">Adding the extension to lagoon road</h3>\n<pre><code><span class="hljs-keyword">const</span> router   = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-client-router\'</span>);\n<span class="hljs-keyword">const</span> road     = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-main\'</span>)(<span class="hljs-string">\'client\'</span>);\nroad\n  .extension(<span class="hljs-string">\'router\'</span>, router, <span class="hljs-literal">true</span>);\n</code></pre><hr>\n<h3 id="router-redirect-path-">router.redirect(path)</h3>\n<pre><code><span class="hljs-selector-tag">router</span><span class="hljs-selector-class">.redirect</span>(<span class="hljs-string">\'/some-page\'</span>);\n</code></pre><p><strong>path:string</strong><br>The path to where you want to redirect, this will trigger an update event on the road.</p>\n<hr>\n\n        </section>\n    ','article'),a()};

},{}],27:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n        <section id="" data="lr-loaded">\n          <h1 id="lr-main-reference">lr-main reference</h1>\n<p>The <em>lr-main</em> package is the only mandatory package for Lagoon road. This package connects everything together, regardless of environment.</p>\n<table>\n<thead>\n<tr>\n<th>Information</th>\n<th>-</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Code coverage</td>\n<td><a href="https://coveralls.io/github/lagoon-road/lr-main?branch=master"><img src="https://coveralls.io/repos/github/lagoon-road/lr-main/badge.svg?branch=master" alt="Coverage Status"></a></td>\n</tr>\n<tr>\n<td>Repo link</td>\n<td><a href="https://github.com/lagoon-road/lr-main">lr-main</a></td>\n</tr>\n<tr>\n<td>Dependencies</td>\n<td><a href="https://github.com/philbooth/check-types.js">check-types</a></td>\n</tr>\n<tr>\n<td>Size (Browserify, Babel and Gzip)</td>\n<td>6.9KB</td>\n</tr>\n<tr>\n<td>Version</td>\n<td>1.0.0</td>\n</tr>\n<tr>\n<td>License</td>\n<td>MIT</td>\n</tr>\n<tr>\n<td>Usage</td>\n<td><a href="/guide">guide</a></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id="core-environmentid-options-">core(environmentId, [options])</h3>\n<pre><code><span class="hljs-attribute">const core</span> = require(<span class="hljs-string">\'lr-main\'</span>);\n<span class="hljs-attribute">const road</span> = core(<span class="hljs-string">\'webserver\'</span>);\n</code></pre><p><strong>environmentId:string</strong><br>The primary environment id for the road, this is the executing environment that will be used when an update event is fired.</p>\n<p><strong>[options.resetAfterCycle:boolean]</strong><br>By default the relay object gets cleared after an update event of the road, sometimes, mainly on the client, you want to keep the relay populated even if an update event has ran. To do so, you can set this boolean to  <em>false</em></p>\n<hr>\n<h3 id="road-parser-parser-">road.parser(parser)</h3>\n<pre><code>const <span class="hljs-keyword">parser</span> = require(<span class="hljs-symbol">\'lr</span>-url-parser\')<span class="hljs-literal">()</span>;\nroad.<span class="hljs-keyword">parser</span>(<span class="hljs-keyword">parser</span>);\n</code></pre><p><strong>parser:object</strong><br>The parser that you want to use to parse an incoming matchValue. It expects two functions in the object, <code>add</code> and <code>parse</code>. Read more about parsers in the <a href="/guide/writing-parsers">guide</a></p>\n<hr>\n<h3 id="road-extension-extensionid-extension-isupdater-">road.extension(extensionId, extension, [isUpdater])</h3>\n<pre><code>road.extension(<span class="hljs-string">\'router\'</span>, router, <span class="hljs-literal">true</span>);\n</code></pre><p><strong>extensionId:string</strong><br>A unique id to identify the extension.</p>\n<p><strong>extension:*</strong><br>The actual extension, this can be any type of code that you want to use</p>\n<p><strong>[isUpdater:boolean = false]</strong><br>Tell the core if on initialization the extension needs to be executed. This is typically for extensions that use update events to trigger updates to the road. Read more about <a href="/guide/writing-extensions">extensions</a> in the guide.</p>\n<blockquote>\n<p>Extensions can be used in middleware via the relay object.</p>\n<pre><code><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">next</span>, relay)</span> =&gt;</span> {\n  console.log(relay.extensions.extensionName);\n  <span class="hljs-built_in">next</span>();\n}\n</code></pre></blockquote>\n<hr>\n<h3 id="road-middleware-middleware-traditional-">road.middleware(middleware, [...traditional])</h3>\n<pre><code>road.middleware({ bodyParser, response }, <span class="hljs-string">\'bodyParser\'</span>, <span class="hljs-string">\'response\'</span>);\n</code></pre><p><strong>middleware:object</strong><br>An object with all the middleware you want to use. This is a single depth object so don&#39;t use any nested structures.</p>\n<blockquote>\n<p>Middleware methods can be called multiple times, the middleware will all be added to a single object within the core. Therefore you need to supply unique ids/keys.\nIf you have a multitude of middleware functions that you  want to use it might be handy to use a dot notation to  group your middleware.</p>\n<pre><code>road.middleware({\n  <span class="hljs-string">\'component.navigation\'</span> : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'...\'</span>),  \n  <span class="hljs-string">\'component.home\'</span>       : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'...\'</span>),  \n});\n</code></pre></blockquote>\n<p><strong>traditional:string</strong>\nThe middleware id of the middleware that you want to run in traditional mode. The relay object wil <em>not</em> be passed in. The traditional function signature looks as follows:</p>\n<pre><code>// traditional, <span class="hljs-built_in">error</span> is optional\n(request, response, <span class="hljs-built_in">next</span>, <span class="hljs-built_in">error</span>) =&gt; {}\n</code></pre><hr>\n<h3 id="road-where-environmentid-environmentid-">road.where(environmentId, [...environmentId])</h3>\n<pre><code>road.<span class="hljs-keyword">where</span>(<span class="hljs-string">\'webserver\'</span>, <span class="hljs-string">\'client\'</span>);\n</code></pre><p><strong>environmentId</strong><br>The where method expects at least one argument, which should be a string. This is an environment id to which all the following middleware will be assigned. If you want to assign middleware to multiple environments you can just specify several ids like in the example above.</p>\n<hr>\n<h3 id="road-run-matchvalue-middlewareid-matchvalue-">road.run(matchValue, middlewareId, [matchValue])</h3>\n<pre><code>road.<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'log\'</span>);\n</code></pre><p><strong>matchValue:string</strong><br>A match value in most webapps can be thought of as an url path, but it is not limited to paths only. Frankly it can be any string you can think of, even a JSON string to match on JSON content. Or in an even more exotic example you can match Raspberry Pie sensor outputs via an extension to string values and let that trigger middleware. You can use the <code>*</code> as a wildcard to match on all match values that might come in.</p>\n<p><strong>middlewareId:string</strong><br>Identifier you added by using the <code>middleware</code> method. It needs to be a string and should match to a middleware function, otherwise it will throw an error.</p>\n<p><strong>[updateType:string]</strong><br>The update type is an extra layer for matching middleware, if we use a http protocol to update the road, this will be the method for the request. By default it wil be <code>GET</code> because it is the most common, but it can be overwritten to be something else. Again you are not limited to http methods, it fully depends on what an extension sends out via an update event.</p>\n<hr>\n<h3 id="road-error-middlewareid-updatetype-">road.error(middlewareId, [updateType])</h3>\n<pre><code>road.<span class="hljs-keyword">error</span>(\'<span class="hljs-built_in">log</span>\')\n</code></pre><p><em>Whenever the stack of middleware that is updated throws an error, it will be redirected to error middleware. You can use it to render alternative content or log the errors. The <code>relay</code> object will have a new property <code>relay.error</code> with the error message.</em></p>\n<p><strong>middlewareId:string</strong><br>Identifier you added by using the <code>middleware</code> method. It needs to be a string and should match to a middleware function, otherwise it will throw.</p>\n<p><strong>[updateType:string]</strong><br>The update type is an extra layer for matching middleware, if we use a http protocol to update the road, this will be the method for the request. By default it wil be <code>GET</code> because it is the most common, but it can be overwritten to be something else. Again you are not limited to http methods, it fully depends on what an extension sends out via an update event.</p>\n<hr>\n<h3 id="road-nomatch-middlewareid-updatetype-">road.noMatch(middlewareId, [updateType])</h3>\n<pre><code><span class="hljs-selector-tag">road</span><span class="hljs-selector-class">.noMatch</span>(<span class="hljs-string">\'log\'</span>);\n</code></pre><p><em>When no middleware could be found for a current combination of <code>matchValue</code> and <code>updateType</code>, the <code>noMatch</code> middleware will be called, this is handy if you want to return a 404 page or something similar.</em></p>\n<p><strong>middlewareId:string</strong><br>Identifier you added by using the <code>middleware</code> method. It needs to be a string and should match to a middleware function, otherwise it will throw.</p>\n<p><strong>[updateType:string]</strong><br>The update type is an extra layer for matching middleware, if we use a http protocol to update the road, this will be the method for the request. By default it wil be <code>GET</code> because it is the most common, but it can be overwritten to be something else. Again you are not limited to http methods, it fully depends on what an extension sends out via an update event.</p>\n<hr>\n<h3 id="road-done-middlewareid-updatetype-">road.done(middlewareId, [updateType])</h3>\n<pre><code><span class="hljs-selector-tag">road</span><span class="hljs-selector-class">.done</span>(<span class="hljs-string">\'response\'</span>, <span class="hljs-string">\'post\'</span>);\n</code></pre><p><em>The <code>done</code> method is called as the last method in the stack, it is typically used to render output (html or json) to a client</em></p>\n<p><strong>middlewareId:string</strong><br>Identifier you added by using the <code>middleware</code> method. It needs to be a string and should match to a middleware function, otherwise it will throw.</p>\n<p><strong>[updateType:string]</strong><br>The update type is an extra layer for matching middleware, if we use a http protocol to update the road, this will be the method for the request. By default it wil be <code>GET</code> because it is the most common, but it can be overwritten to be something else. Again you are not limited to http methods, it fully depends on what an extension sends out via an update event.</p>\n<hr>\n<h3 id="road-update-options-object-parameters-">road.update(options:object, [...parameters])</h3>\n<pre><code><span class="hljs-selector-tag">road</span><span class="hljs-selector-class">.update</span>({ <span class="hljs-attribute">matchValue </span>: <span class="hljs-string">\'/somepath\'</span>, updateType : <span class="hljs-string">\'post\'</span> }, <span class="hljs-selector-tag">parameterOne</span>, <span class="hljs-selector-tag">parameterTwo</span>);\n</code></pre><p><em>Manually trigger an update event to the road by calling the <code>update</code> method.</em></p>\n<p><strong>options.matchValue:string</strong><br>A match value in most webapps can be thought of as an url path, but it is not limited to paths only. Frankly it can be any string you can think of, even a JSON string to match on JSON content. Or in an even more exotic example you can match Raspberry pie sensor outputs via an extension to string values and let that trigger middleware. You can use the <code>*</code> as a wildcard to match on all match values that might come in.</p>\n<p><strong>options.updateType:string</strong><br>The update type is an extra layer for matching middleware, if we use a http protocol to update the road, this will be the method for the request. By default it wil be <code>GET</code> because it is the most common, but it can be overwritten to be something else. Again you are not limited to http methods, it fully depends on what an extension sends out via an update event.</p>\n<p><strong>parameters:*</strong><br>Each update can be have custom parameters that will be available as middleware arguments. This could be for example the <code>request</code> and <code>response</code> object on a router update.</p>\n<blockquote>\n<p>Read more about parameters in the <a href="/guide/update-and-middleware-stack">update and middleware stack</a> section.\nEvery time a update method is called the middleware that matches will be added to the stack of middleware that needs to be executed. So when calling this on the server you might send out a response and afterwards more middleware will be called. Therefore use it on the client mainly to initialize events. Make sure you fully understand the middelware stack before start using the update function.</p>\n</blockquote>\n<h2 id="relay-object">Relay object</h2>\n<p>The relay object is passed from middleware function to middleware function. There are a couple of properties and methods in this object that cannot be overwritten. If you will try to do so, Lagoon road will throw an error to warn you of naming conflicts.</p>\n<h3 id="relay-extensions-object">relay.extensions:object</h3>\n<p>An Object that has all the registered extensions in it. This way all extensions will not get scattered all over the object.</p>\n<h3 id="relay-parameters-object">relay.parameters:object</h3>\n<p>If you are using a parser that supplies you with parameters like <code>lr-url-parser</code>, you can access them via <code>relay.parameters</code>.</p>\n<h3 id="relay-update-options-object-function">relay.update(options:object):function</h3>\n<p>See update method for usage.</p>\n<h3 id="relay-exit-function">relay.exit():function</h3>\n<p>When you want to prematurely finish the update cycle you have to call the <code>exit()</code> function. You want to use this when you want to send a <code>response.end</code> before the <code>done</code> hook. This function should be used rarely, read more about it in the <a href="/guide/update-and-middleware-stack">stack</a> and <a href="/guide/handling-static-content">static content</a> guides.</p>\n\n        </section>\n    ','article'),a()};

},{}],28:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n        <section id="" data="lr-loaded">\n          <h1 id="lr-server-renderer-reference">lr-server-renderer reference</h1>\n<p>Server side renderer for lagoon road.</p>\n<table>\n<thead>\n<tr>\n<th>Information</th>\n<th>-</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Code coverage</td>\n<td><a href="https://coveralls.io/github/lagoon-road/lr-server-renderer?branch=master"><img src="https://coveralls.io/repos/github/lagoon-road/lr-server-renderer/badge.svg?branch=master" alt="Coverage Status"></a></td>\n</tr>\n<tr>\n<td>Repo link</td>\n<td><a href="https://github.com/lagoon-road/lr-server-renderer">lr-server-renderer</a></td>\n</tr>\n<tr>\n<td>Dependencies</td>\n<td><a href="https://github.com/cheeriojs/cheerio">cheerio</a></td>\n</tr>\n<tr>\n<td>Size (ex. dependencies)</td>\n<td>612 bytes</td>\n</tr>\n<tr>\n<td>Version</td>\n<td>1.0.0</td>\n</tr>\n<tr>\n<td>License</td>\n<td>MIT</td>\n</tr>\n<tr>\n<td>Usage</td>\n<td><a href="/guide">guide</a></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id="renderer-template-html-">renderer.template(html)</h3>\n<pre><code>renderer.template(<span class="hljs-comment">\'<span class="hljs-doctag">&lt;html&gt;</span>...<span class="hljs-doctag">&lt;/html&gt;</span>\');</span>\n</code></pre><p><em>Method sets the template for the output, all components will be added to this template</em></p>\n<p><strong>html:string</strong><br>The template you want to use for the components and state that you might want to add.</p>\n<hr>\n<h3 id="renderer-render-html-placeholder-">renderer.render(html, placeholder)</h3>\n<pre><code><span class="hljs-keyword">renderer</span>.<span class="hljs-keyword">render</span>(<span class="hljs-string">\'&lt;section&gt;...&lt;/section&gt;\'</span>, <span class="hljs-string">\'.placeholderName\'</span>);\n</code></pre><p><em>Adds a component to the template.</em></p>\n<p><strong>html:string</strong><br>The components html that you want to load.</p>\n<p><strong>placeholder:string</strong><br>A html selector that should be the parent of the html you want to add. The contents of the placeholder will be removed before adding the new html.</p>\n<hr>\n<h3 id="renderer-state-state-">renderer.state(state)</h3>\n<pre><code><span class="hljs-selector-tag">renderer</span><span class="hljs-selector-class">.state</span>({ <span class="hljs-attribute">data </span>: [...], otherProperties : true });\n</code></pre><p><em>Add data to a script tag that you can access on the client again. This prevents loading the same data. The data will be available by accessing <code>window.__state__</code> as json.</em></p>\n<p><strong>state:object</strong><br>An object that has been loaded on the server that you want to transfer to the client.</p>\n<hr>\n<h3 id="renderer-html-">renderer.html()</h3>\n<pre><code>renderer.html()<span class="hljs-comment">;</span>\n</code></pre><p><em>Get the final output of the template and components that you have created, this data can be send back as the response to the client.</em></p>\n\n        </section>\n    ','article'),a()};

},{}],29:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n        <section id="" data="lr-loaded">\n          <h1 id="lr-server-router-reference">lr-server-router reference</h1>\n<p>A Lagoon road extension that gives you route functionality on the server.</p>\n<table>\n<thead>\n<tr>\n<th>Information</th>\n<th>-</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Code coverage</td>\n<td><a href="https://coveralls.io/github/lagoon-road/lr-server-router?branch=master"><img src="https://coveralls.io/repos/github/lagoon-road/lr-server-router/badge.svg?branch=master" alt="Coverage Status"></a></td>\n</tr>\n<tr>\n<td>Repo link</td>\n<td><a href="https://github.com/lagoon-road/lr-server-router">lr-server-router</a></td>\n</tr>\n<tr>\n<td>Dependencies</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Size</td>\n<td>336 bytes</td>\n</tr>\n<tr>\n<td>Version</td>\n<td>1.0.1</td>\n</tr>\n<tr>\n<td>License</td>\n<td>MIT</td>\n</tr>\n<tr>\n<td>Usage</td>\n<td><a href="/guide">guide</a></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id="function-initialization">Function initialization</h3>\n<p>This package doesn&#39;t have any exposed methods, it does however needs a single argument on creation.</p>\n<pre><code><span class="hljs-attribute">const protocol</span> = require(<span class="hljs-string">\'http\'</span>);\n<span class="hljs-attribute">const server</span>   = protocol.createServer();\n<span class="hljs-attribute">const router</span>   = require(<span class="hljs-string">\'lr-server-router\'</span>)(server);\n<span class="hljs-attribute">const core</span>     = require(<span class="hljs-string">\'lr-main\'</span>);\n<span class="hljs-attribute">const road</span>     = core(<span class="hljs-string">\'webserver\'</span>)\n  .extension(<span class="hljs-string">\'router\'</span>, router, true);\n</code></pre><hr>\n\n        </section>\n    ','article'),a()};

},{}],30:[function(require,module,exports){
'use strict';module.exports=function(a,b){b.extensions.renderer.render('\n        <section id="" data="lr-loaded">\n          <h1 id="lr-url-parser">lr-url-parser</h1>\n<p>Parser that can take placeholders from urls and match them with real urls</p>\n<table>\n<thead>\n<tr>\n<th>Information</th>\n<th>-</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Code coverage</td>\n<td><a href="https://coveralls.io/github/lagoon-road/lr-url-parser?branch=master"><img src="https://coveralls.io/repos/github/lagoon-road/lr-url-parser/badge.svg?branch=master" alt="Coverage Status"></a></td>\n</tr>\n<tr>\n<td>Repo link</td>\n<td><a href="https://github.com/lagoon-road/lr-client-router">lr-client-router</a></td>\n</tr>\n<tr>\n<td>Dependencies</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Size (Browserify, Babel and Gzip)</td>\n<td>777 bytes</td>\n</tr>\n<tr>\n<td>Version</td>\n<td>1.0.0</td>\n</tr>\n<tr>\n<td>License</td>\n<td>MIT</td>\n</tr>\n<tr>\n<td>Usage</td>\n<td><a href="/guide">guide</a></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id="adding-the-parser-to-lagoon-road">Adding the parser to lagoon road</h3>\n<pre><code><span class="hljs-selector-tag">require</span>(<span class="hljs-string">\'lr-main\'</span>)(<span class="hljs-string">\'client\'</span>)\n  <span class="hljs-selector-class">.parser</span>(require(<span class="hljs-string">\'lr-url-parser\'</span>));\n</code></pre><hr>\n<h3 id="parser-add-path-">parser.add(path)</h3>\n<pre><code>parser.<span class="hljs-keyword">add</span>(<span class="hljs-string">\'blog/:id\'</span>);\n</code></pre><p><strong>path:string</strong><br>Add a route including placeholders to the parser, it will use it later for parsing.</p>\n<hr>\n<h3 id="parser-parse-path-">parser.parse(path)</h3>\n<pre><code>parser.parse(<span class="hljs-symbol">\'blog</span>/<span class="hljs-number">1</span>\');\n// Returns { path : \'<span class="hljs-type">blog</span>/:id\', parameters : { <span class="hljs-type">id</span> : 1 } }\n</code></pre><p><strong>path:string</strong><br>Parse an incoming route and check if it exists. If it exists it will extract possible parameters and give back the original url. If no match could be made the path is returned in object form like <code>{ path : &#39;/original-path&#39; }</code>.</p>\n<hr>\n\n        </section>\n    ','article'),a()};

},{}],31:[function(require,module,exports){
'use strict';module.exports=function(a){var c=document.querySelector('.logo');'/'===window.location.pathname?c.classList.remove('compact'):c.classList.add('compact'),a()};

},{}]},{},[5]);
