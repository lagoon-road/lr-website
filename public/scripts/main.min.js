(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){module.exports=(update=>{let placeholders={};function addObserver(id){const observer=new MutationObserver(function(mutations){mutations.forEach(function(mutation){if(mutation.attributeName==="lg-placeholder"){update({matchValue:window.location.pathname,updateType:"domReady"})}})});observer.observe(document.querySelector(id),{attributes:true,childList:false,subtree:false});placeholders[id].observer=observer}const exposed={render(html,id){if(placeholders[id]&&placeholders[id].observer){placeholders[id].observer.disconnect()}placeholders[id]={html:html}},html(){Object.keys(placeholders).filter(id=>placeholders[id].html).forEach(id=>{if(!document.querySelector(id)){throw new Error(`Trying to render, but could not find placeholder ${id}`)}addObserver(id);document.querySelector(id).innerHTML=placeholders[id].html;document.querySelector(id).setAttribute("lg-placeholder",id);delete placeholders[id].html})}};return exposed})},{}],2:[function(require,module,exports){module.exports=(update=>{document.addEventListener("click",event=>{if(event.target.nodeName.toLowerCase()==="a"&&event.target.getAttribute("href")&&event.target.getAttribute("href")[0]==="/"){event.preventDefault();const url=event.target.getAttribute("href");history.pushState({url:url},url,url);update({matchValue:url},{url:url})}});window.onpopstate=function(request){if(request&&request.state&&request.state.url){update({matchValue:request.state.url},request.state)}};return{redirect(url){history.pushState({url:url},url,url);update({matchValue:url},{url:url})}}})},{}],3:[function(require,module,exports){const check=require("check-types");module.exports=((environmentId,options={})=>{const defaultUpdateType="get";let resetAfterCycle=true;let traditional=[];let stack=[];let extensions={};let relay;let parser=require("lr-url-parser")();let availableMiddleware={};let executingEnvironmentId=environmentId;let selectedEnvironmentIds=[environmentId];let environments={};const exposed={extension:extension,middleware:middleware,where:where,run:run,error:error,noMatch:noMatch,done:done,update:update};if(options.parser){check.assert.function(options.parser.add,'Parser needs to have a method called "add"');check.assert.function(options.parser.parse,'Parser needs to have a method called "parse"');parser=options.parser}if(options.resetAfterCycle!==undefined){check.assert.boolean(options.resetAfterCycle,"resetAfterCycle needs to be a boolean");resetAfterCycle=options.resetAfterCycle}environments[environmentId]=environment(environmentId);relay=setRelay();function setRelay(){if(resetAfterCycle){return{extensions:extensions}}else if(!relay){return{extensions:{}}}else{return relay}}function environment(id){check.assert.not.undefined(id,"Environment id cannot be empty");check.assert.match(id,/^[a-z0-9]+$/i,"Environment id needs to be a string containing only letters and or numbers");return{id:id,matches:{},middleware:[],noMatch:[],error:[],done:[]}}function extension(id,extension,isUpdater=false){check.assert.not.undefined(id,"Extension id cannot be empty");check.assert.not.undefined(extension,"Extension cannot be empty");check.assert.match(id,/^[a-z0-9]+$/i,"Extension id needs to be a string containing only letters and or numbers");check.assert.not.assigned(extensions[id],`"${id}" has already been defined as an extension`);extensions[id]=isUpdater?extension(update):extension;return exposed}function middleware(newMiddleware,...traditionals){check.assert.nonEmptyObject(newMiddleware,"Provided middleware needs to be a non empty object");Object.keys(newMiddleware).forEach(id=>{check.assert.not.assigned(availableMiddleware[id],`"${id}" has already been defined as middleware`);check.assert.function(newMiddleware[id],`"${id}" middleware is not a function`)});if(traditionals.length){check.assert.array.of.string(traditionals,"All traditional middleware names need to be strings");traditionals.forEach((id,index)=>{check.assert.equal(traditionals.indexOf(id),index,`Duplicate values found for traditional middleware "${id}"`);check.assert.equal(traditional.indexOf(id),-1,`"${id}" has already been defined as a traditional middleware function`)});traditional=[...traditional,...traditionals]}availableMiddleware=Object.assign({},availableMiddleware,newMiddleware);return exposed}function where(...environmentIds){check.assert.greater(environmentIds.length,0,"Where method missing parameters");environmentIds.forEach(id=>{check.assert.not.undefined(id,"Environment id cannot be empty");check.assert.match(id,/^[a-z0-9]+$/i,"Environment id needs to be a string containing only letters and or numbers");if(!environments[id]){environments[id]=environment(id)}});selectedEnvironmentIds=environmentIds;return exposed}function run(matchValue,middlewareId,updateType=defaultUpdateType){check.assert.not.undefined(matchValue,"Match value cannot be empty");check.assert.string(matchValue,"Match value needs to be a string");check.assert.not.undefined(middlewareId,"Middleware id cannot be empty");check.assert.match(middlewareId,/^[a-z0-9\.]+$/i,'Middleware id needs to be a string containing only letters,numbers and an optional "."');check.assert.match(updateType,/^[a-z0-9]+$/i,"Update type needs to be a string containing only letters and or numbers");selectedEnvironmentIds.forEach(environmentId=>{environments[environmentId].middleware.push({matchValue:matchValue,id:middlewareId,updateType:updateType.toLowerCase()})});return exposed}function error(middlewareId,updateType=defaultUpdateType){check.assert.zero(arguments.length-1,"Error needs exactly one argument");check.assert.match(middlewareId,/^[a-z0-9\.]+$/i,'Middleware id needs to be a string containing only letters,numbers and an optional "."');selectedEnvironmentIds.forEach(id=>environments[id].error.push({id:middlewareId,updateType:updateType}));return exposed}function noMatch(middlewareId,updateType=defaultUpdateType){check.assert.zero(arguments.length-1,"NoMatch needs exactly one argument");check.assert.match(middlewareId,/^[a-z0-9\.]+$/i,'Middleware id needs to be a string containing only letters,numbers and an optional "."');selectedEnvironmentIds.forEach(id=>environments[id].noMatch.push({id:middlewareId,updateType:updateType}));return exposed}function done(middlewareId,updateType=defaultUpdateType){check.assert.zero(arguments.length-1,"Done needs exactly one argument");check.assert.match(middlewareId,/^[a-z0-9\.]+$/i,'Middleware id needs to be a string containing only letters,numbers and an optional "."');selectedEnvironmentIds.forEach(id=>environments[id].done.push({id:middlewareId,updateType:updateType}));return exposed}function update(options,...parameters){check.assert.assigned(options.matchValue,"Update function cannot find a matchValue");const matchValue=parser.parse(options.matchValue);const updateType=options.updateType?options.updateType.toLowerCase():defaultUpdateType;relay=setRelay();relay.parameters=matchValue.parameters;const environment=environments[executingEnvironmentId];let middleware=environment.middleware.filter(record=>record.matchValue===matchValue.path||record.matchValue==="*").filter(record=>record.updateType===updateType);stack=[...stack,...middleware];function addNoMatchMiddleware(){stack=[...stack,...environment.noMatch.filter(middleware=>middleware.updateType===updateType)]}function addDoneMiddleware(){stack=[...stack,...environment.done.filter(middleware=>middleware.updateType===updateType)]}function addErrorMiddleware(){stack=[...stack,...environment.error.filter(middleware=>middleware.updateType===updateType)]}if(middleware.length===0){addNoMatchMiddleware()}addDoneMiddleware();function thunkify(record){const id=record.id;const callback=availableMiddleware[id];check.assert.assigned(callback,`Middleware ${id} not found`);check.assert.function(callback,"Middleware needs to be a function");return function(defined={}){check.assert.object(defined,"Relay additions need to be an object");relay=Object.assign({},relay,defined);const next=stack.length===0?()=>{}:thunkify(stack.shift());if(traditional.indexOf(id)>-1){callback(...parameters,next)}else{callback(next,relay,...parameters)}}}try{if(stack.length>0){thunkify(stack.shift())(relay)}else{console.warn(`No middleware found for current update cycle matchValue: ${matchValue.path}, updateType: ${updateType}`)}}catch(error){stack=[];addErrorMiddleware();addDoneMiddleware();relay.error=error;if(stack.length>0){thunkify(stack.shift())(relay)}else{console.error(`Error but no middleware found, path: ${matchValue.path}, updateType: ${updateType}`);console.error(error)}}}return exposed})},{"check-types":4,"lr-url-parser":5}],4:[function(require,module,exports){(function(globals){"use strict";var strings,messages,predicates,functions,assert,not,maybe,collections,slice;strings={v:"value",n:"number",s:"string",b:"boolean",o:"object",t:"type",a:"array",al:"array-like",i:"iterable",d:"date",f:"function",l:"length"};messages={};predicates={};[{n:"equal",f:equal,s:"v"},{n:"undefined",f:isUndefined,s:"v"},{n:"null",f:isNull,s:"v"},{n:"assigned",f:assigned,s:"v"},{n:"includes",f:includes,s:"v"},{n:"zero",f:zero},{n:"infinity",f:infinity},{n:"number",f:number},{n:"integer",f:integer},{n:"even",f:even},{n:"odd",f:odd},{n:"greater",f:greater},{n:"less",f:less},{n:"between",f:between},{n:"greaterOrEqual",f:greaterOrEqual},{n:"lessOrEqual",f:lessOrEqual},{n:"inRange",f:inRange},{n:"positive",f:positive},{n:"negative",f:negative},{n:"string",f:string,s:"s"},{n:"emptyString",f:emptyString,s:"s"},{n:"nonEmptyString",f:nonEmptyString,s:"s"},{n:"contains",f:contains,s:"s"},{n:"match",f:match,s:"s"},{n:"boolean",f:boolean,s:"b"},{n:"object",f:object,s:"o"},{n:"emptyObject",f:emptyObject,s:"o"},{n:"nonEmptyObject",f:nonEmptyObject,s:"o"},{n:"instanceStrict",f:instanceStrict,s:"t"},{n:"instance",f:instance,s:"t"},{n:"like",f:like,s:"t"},{n:"array",f:array,s:"a"},{n:"emptyArray",f:emptyArray,s:"a"},{n:"nonEmptyArray",f:nonEmptyArray,s:"a"},{n:"arrayLike",f:arrayLike,s:"al"},{n:"iterable",f:iterable,s:"i"},{n:"date",f:date,s:"d"},{n:"function",f:isFunction,s:"f"},{n:"hasLength",f:hasLength,s:"l"}].map(function(data){var n=data.n;messages[n]="Invalid "+strings[data.s||"n"];predicates[n]=data.f});functions={apply:apply,map:map,all:all,any:any};collections=["array","arrayLike","iterable","object"];slice=Array.prototype.slice;functions=mixin(functions,predicates);assert=createModifiedPredicates(assertModifier,assertImpl);not=createModifiedPredicates(notModifier,notImpl);maybe=createModifiedPredicates(maybeModifier,maybeImpl);assert.not=createModifiedModifier(assertModifier,not);assert.maybe=createModifiedModifier(assertModifier,maybe);collections.forEach(createOfPredicates);createOfModifiers(assert,assertModifier);createOfModifiers(not,notModifier);collections.forEach(createMaybeOfModifiers);exportFunctions(mixin(functions,{assert:assert,not:not,maybe:maybe}));function equal(lhs,rhs){return lhs===rhs}function isUndefined(data){return data===undefined}function isNull(data){return data===null}function assigned(data){return!isUndefined(data)&&!isNull(data)}function zero(data){return data===0}function infinity(data){return data===Number.POSITIVE_INFINITY||data===Number.NEGATIVE_INFINITY}function number(data){return typeof data==="number"&&isNaN(data)===false&&data!==Number.POSITIVE_INFINITY&&data!==Number.NEGATIVE_INFINITY}function integer(data){return number(data)&&data%1===0}function even(data){return number(data)&&data%2===0}function odd(data){return integer(data)&&!even(data)}function greater(lhs,rhs){return number(lhs)&&lhs>rhs}function less(lhs,rhs){return number(lhs)&&lhs<rhs}function between(data,x,y){if(x<y){return greater(data,x)&&less(data,y)}return less(data,x)&&greater(data,y)}function greaterOrEqual(lhs,rhs){return number(lhs)&&lhs>=rhs}function lessOrEqual(lhs,rhs){return number(lhs)&&lhs<=rhs}function inRange(data,x,y){if(x<y){return greaterOrEqual(data,x)&&lessOrEqual(data,y)}return lessOrEqual(data,x)&&greaterOrEqual(data,y)}function positive(data){return greater(data,0)}function negative(data){return less(data,0)}function string(data){return typeof data==="string"}function emptyString(data){return data===""}function nonEmptyString(data){return string(data)&&data!==""}function contains(data,substring){return string(data)&&data.indexOf(substring)!==-1}function match(data,regex){return string(data)&&!!data.match(regex)}function boolean(data){return data===false||data===true}function object(data){return Object.prototype.toString.call(data)==="[object Object]"}function emptyObject(data){return object(data)&&Object.keys(data).length===0}function nonEmptyObject(data){return object(data)&&Object.keys(data).length>0}function instanceStrict(data,prototype){try{return data instanceof prototype}catch(error){return false}}function instance(data,prototype){try{return instanceStrict(data,prototype)||data.constructor.name===prototype.name||Object.prototype.toString.call(data)==="[object "+prototype.name+"]"}catch(error){return false}}function like(data,archetype){var name;for(name in archetype){if(archetype.hasOwnProperty(name)){if(data.hasOwnProperty(name)===false||typeof data[name]!==typeof archetype[name]){return false}if(object(data[name])&&like(data[name],archetype[name])===false){return false}}}return true}function array(data){return Array.isArray(data)}function emptyArray(data){return array(data)&&data.length===0}function nonEmptyArray(data){return array(data)&&data.length>0}function arrayLike(data){return assigned(data)&&number(data.length)}function iterable(data){if(typeof Symbol==="undefined"){return arrayLike(data)}return assigned(data)&&isFunction(data[Symbol.iterator])}function includes(data,value){var iterator,iteration;if(not.assigned(data)){return false}try{if(typeof Symbol!=="undefined"&&data[Symbol.iterator]&&isFunction(data.values)){iterator=data.values();do{iteration=iterator.next();if(iteration.value===value){return true}}while(!iteration.done);return false}Object.keys(data).forEach(function(key){if(data[key]===value){throw 0}})}catch(ignore){return true}return false}function hasLength(data,length){return assigned(data)&&data.length===length}function date(data){try{return instance(data,Date)&&integer(data.getTime())}catch(error){return false}}function isFunction(data){return typeof data==="function"}function apply(data,predicates){assert.array(data);if(isFunction(predicates)){return data.map(function(value){return predicates(value)})}assert.array(predicates);assert.hasLength(data,predicates.length);return data.map(function(value,index){return predicates[index](value)})}function map(data,predicates){assert.object(data);if(isFunction(predicates)){return mapSimple(data,predicates)}assert.object(predicates);return mapComplex(data,predicates)}function mapSimple(data,predicate){var result={};Object.keys(data).forEach(function(key){result[key]=predicate(data[key])});return result}function mapComplex(data,predicates){var result={};Object.keys(predicates).forEach(function(key){var predicate=predicates[key];if(isFunction(predicate)){if(not.assigned(data)){result[key]=!!predicate.m}else{result[key]=predicate(data[key])}}else if(object(predicate)){result[key]=mapComplex(data[key],predicate)}});return result}function all(data){if(array(data)){return testArray(data,false)}assert.object(data);return testObject(data,false)}function testArray(data,result){var i;for(i=0;i<data.length;i+=1){if(data[i]===result){return result}}return!result}function testObject(data,result){var key,value;for(key in data){if(data.hasOwnProperty(key)){value=data[key];if(object(value)&&testObject(value,result)===result){return result}if(value===result){return result}}}return!result}function any(data){if(array(data)){return testArray(data,true)}assert.object(data);return testObject(data,true)}function mixin(target,source){Object.keys(source).forEach(function(key){target[key]=source[key]});return target}function assertModifier(predicate,defaultMessage){return function(){assertPredicate(predicate,arguments,defaultMessage)}}function assertPredicate(predicate,args,defaultMessage){var argCount=predicate.l||predicate.length;var message=args[argCount];var ErrorType=args[argCount+1];assertImpl(predicate.apply(null,args),nonEmptyString(message)?message:defaultMessage,isFunction(ErrorType)?ErrorType:TypeError)}function assertImpl(value,message,ErrorType){if(value===false){throw new(ErrorType||Error)(message||"Assertion failed")}}function notModifier(predicate){var modifiedPredicate=function(){return notImpl(predicate.apply(null,arguments))};modifiedPredicate.l=predicate.length;return modifiedPredicate}function notImpl(value){return!value}function maybeModifier(predicate){var modifiedPredicate=function(){if(not.assigned(arguments[0])){return true}return predicate.apply(null,arguments)};modifiedPredicate.l=predicate.length;modifiedPredicate.m=true;return modifiedPredicate}function maybeImpl(value){if(assigned(value)===false){return true}return value}function ofModifier(target,type,predicate){var modifiedPredicate=function(){var collection,args;collection=arguments[0];if(target==="maybe"&&not.assigned(collection)){return true}if(!type(collection)){return false}collection=coerceCollection(type,collection);args=slice.call(arguments,1);try{collection.forEach(function(item){if((target!=="maybe"||assigned(item))&&!predicate.apply(null,[item].concat(args))){throw 0}})}catch(ignore){return false}return true};modifiedPredicate.l=predicate.length;return modifiedPredicate}function coerceCollection(type,collection){switch(type){case arrayLike:return slice.call(collection);case object:return Object.keys(collection).map(function(key){return collection[key]});default:return collection}}function createModifiedPredicates(modifier,object){return createModifiedFunctions([modifier,predicates,object])}function createModifiedFunctions(args){var modifier,object,functions,result;modifier=args.shift();object=args.pop();functions=args.pop();result=object||{};Object.keys(functions).forEach(function(key){Object.defineProperty(result,key,{configurable:false,enumerable:true,writable:false,value:modifier.apply(null,args.concat(functions[key],messages[key]))})});return result}function createModifiedModifier(modifier,modified){return createModifiedFunctions([modifier,modified,null])}function createOfPredicates(key){predicates[key].of=createModifiedFunctions([ofModifier.bind(null,null),predicates[key],predicates,null])}function createOfModifiers(base,modifier){collections.forEach(function(key){base[key].of=createModifiedModifier(modifier,predicates[key].of)})}function createMaybeOfModifiers(key){maybe[key].of=createModifiedFunctions([ofModifier.bind(null,"maybe"),predicates[key],predicates,null]);assert.maybe[key].of=createModifiedModifier(assertModifier,maybe[key].of);assert.not[key].of=createModifiedModifier(assertModifier,not[key].of)}function exportFunctions(functions){if(typeof define==="function"&&define.amd){define(function(){return functions})}else if(typeof module!=="undefined"&&module!==null&&module.exports){module.exports=functions}else{globals.check=functions}}})(this)},{}],5:[function(require,module,exports){"use-strict";module.exports=function(){let paths=[];let unique={};function parts(path){let parts=path.split("?").shift().split("/");parts.shift();return parts.map(part=>{return{root:!part?true:false,static:part[0]!==":",value:part[0]===":"?part.slice(1):part}})}return{add(path){if(path[0]==="/"&&!unique[path]){paths.push({path:path,parts:parts(path)});unique[path]=true;return true}else{return false}},parse(path){if(path[0]!=="/"){return{path:path}}const needle=parts(path);let match=paths.filter(path=>path.parts.length===needle.length).filter(path=>{return path.parts.filter((part,index)=>{return part.value!==needle[index].value&&part.static}).length===0});if(match.length>0){match=match.pop()}if(!Array.isArray(match)){let parameters={};match.parts.forEach((part,index)=>{if(!part.static){parameters[part.value]=parseInt(needle[index].value)}});return{path:match.path,parameters:parameters}}return{path:path.split("?").shift()}}}}},{}],6:[function(require,module,exports){"use strict";document.addEventListener("DOMContentLoaded",function(event){var router=require("lr-client-router");var renderer=require("lr-client-renderer");var road=require("lr-core")("client");road.extension("router",router,true).extension("renderer",renderer,true).middleware({"response.html":function responseHtml(next,relay){relay.extensions.renderer.html()},"events.navigation":require("../middleware/events/navigation")});require("./road")(road).where("client").update({matchValue:window.location.pathname,updateType:"domReady"})})},{"../middleware/events/navigation":21,"./road":7,"lr-client-renderer":1,"lr-client-router":2,"lr-core":3}],7:[function(require,module,exports){"use strict";module.exports=function(road){road.where("webserver","client").middleware({debug:function debug(next,relay,request){console.log(request.url);next()},"components.navigation":require("../middleware/components/navigation"),"components.home":require("../middleware/components/home"),"components.reference":require("../middleware/components/reference"),"components.lrCore":require("../middleware/components/reference/lr-core"),"components.lrServerRouter":require("../middleware/components/reference/lr-server-router"),"components.lrServerRenderer":require("../middleware/components/reference/lr-server-renderer"),"components.lrClientRouter":require("../middleware/components/reference/lr-client-router"),"components.lrClientRenderer":require("../middleware/components/reference/lr-client-renderer"),"components.lrUrlParser":require("../middleware/components/reference/lr-url-parser"),"components.faq":require("../middleware/components/faq"),"components.guide":require("../middleware/components/guide"),"components.error":require("../middleware/components/error"),"components.noMatch":require("../middleware/components/noMatch")}).run("*","debug").where("webserver").run("*","layouts.default").run("*","components.navigation").noMatch("layouts.default").where("client").run("*","events.navigation","domReady").where("webserver","client").run("/","components.home").run("/guide","components.guide").run("/reference","components.reference").run("/reference/lr-core","components.lrCore").run("/reference/lr-server-router","components.lrServerRouter").run("/reference/lr-server-renderer","components.lrServerRenderer").run("/reference/lr-client-router","components.lrClientRouter").run("/reference/lr-client-renderer","components.lrClientRenderer").run("/reference/lr-url-parser","components.lrUrlParser").run("/faq","components.faq").noMatch("components.noMatch").error("components.error").done("response.html");return road}},{"../middleware/components/error":8,"../middleware/components/faq":9,"../middleware/components/guide":10,"../middleware/components/home":11,"../middleware/components/navigation":12,"../middleware/components/noMatch":13,"../middleware/components/reference":14,"../middleware/components/reference/lr-client-renderer":15,"../middleware/components/reference/lr-client-router":16,"../middleware/components/reference/lr-core":17,"../middleware/components/reference/lr-server-renderer":18,"../middleware/components/reference/lr-server-router":19,"../middleware/components/reference/lr-url-parser":20}],8:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render("\n    <h1>Error</h1>\n    <pre>"+relay.error+"</pre>\n  ","article");next()}},{}],9:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n    <h1>FAQ</h1>\n    <p>Answers to some common questions you might have. Cannot find an answer? Please open an <a href="https://github.com/lagoon-road/lr-core/issues/new">issue</a> on Github. I will keep this list up to date so all questions asked on Github that have any merit will be added to this list.</p>\n    <ul class="submenu">\n      <li><a href="#which-versions-of-node-are-supported">Which versions of node are supported?</a></li>\n      <li><a href="#does-a-single-road-not-create-overhead-in-other-environments">Does a single road not create overhead in other environments?</a></li>\n      <li><a href="#what-is-the-best-directory-structure-for-my-project">What is the best directory structure for my project?</a></li>\n      <li><a href="#who-created-lagoon-road">Who created Lagoon road?</a></li>\n      <li><a href="#where-does-the-name-come-from">Where does the name come from?</a></li>\n    </ul>\n    <h3><a name="which-versions-of-node-are-supported">Which versions of node are supported?</a></h3>\n    <p>The packages have hardly any dependencies and are very much just plain javascript, so everything from node 4.x up I expect to work. The code is written with ES6 so you might need to compile your code first with Babel to get it to run. Best practice is to use the newest version of node, for the simple reason that I haven\'t tested older versions. I developed with node 7.6.x</p>\n    <h3><a name="does-a-single-road-not-create-overhead-in-other-environments">Does a single road not create overhead in other environments?</a></h3>\n    <p>Yes, combining the middleware in a single place, will create overhead. But compared to what you gain from having everything connected in a single place, it is negligible. You will only create some extra properties on the internal objects within the core. Whenever the update event is fired the matches are done based on object key matches, so there is no extra filtering needed. Performance wise not really an issue.</p>\n\n    <h3><a name="what-is-the-best-directory-structure-for-my-project">What is the best directory structure for my project?</a></h3>\n    <p>Lagoon road doesn\'t force any structure on you. That is the phylosophy of Lagoon road, that you don\'t have to tie yourself down to any methodologies or structures. You want to work more in a component based manner, you can do so. Want to seperate your scripts from your styles, because you reuse your css over multiple components, also possible.</p>\n    <p>This is the structure that I\'ve used for this website</p>\n    <pre>\n- source\n| - bootstrap\n  | - client.js\n  | - server.js\n  | - road.js\n| - extensions\n  | - settings\n    | - webserver.js\n| - middleware\n  | - components\n    | - .. every component in a single file\n  | - layouts\n    | .. every layout in a single file\n  | - events\n    | - .. client side dom code, every component in a single file\n  | - response\n    | - response.js (html response for the webserver)\n| - stylesheets\n  | - components\n    | .. every component in a single file\n  | - layouts\n    | .. every layout in a single file\n  | - .. some more general styles, like animation and typography\n  | - styles.css (importing all other styles)\n    </pre>\n    <p>Then all client side code will be pass through babel and browserify and the minifier. View the <a href="https://github.com/lagoon-road/lr-website/blob/master/package.json">package.json</a> and the <a href="https://github.com/lagoon-road/lr-website">lr-website code</a></p>\n\n\n    <h3><a name="who-created-lagoon-road">Who created Lagoon road?</a></h3>\n    <p><a href="http://royniels.nl">Check my website</a></p>\n\n    <h3><a name="where-does-the-name-come-from">Where does the name come from?</a></h3>\n    <p>\n      The name comes from one of my favorite books, <em><a href="https://www.amazon.com/Surviving-Paradise-Year-Disappearing-Island/dp/B0044KN3CO">Surviving Paradise: One Year on a Disappearing Island</a></em>. At some point the protagonist is back on Majuro, an island in the Marshall Islands group and talks about the single road on the island.\n    </p>\n    <blockquote>\n      Taxis were a snap—stand on the appropriate side of the street, ﬂag down one of the six cabs that arrived every minute, and then sit in the cool dryness of the air-conditioning and enjoy the ride. No need to tell the driver your destination: since there was only one real road, you could simply tell him when to stop.\n    </blockquote>\n    <p>The road that he is talking about is called Lagoon road, and since I am residing on Bali, a link with islands and the single road concept seemed like a good metaphore for the single object structure of Lagoon road.\n  ',"article");next()}},{}],10:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render("\n    <h1>Guide</h1>\n  ","article");next()}},{}],11:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n    <section class="home">\n      <div class="logo-text">\n        <h1>Lagoon road <span>Laid back webapps</span></h1>\n      </div>\n      <hr>\n      <p class="standout">Lagoon road helps you build webapps. It is not as low level as writing Javascript from scratch and it is not as high level as frameworks that can limit your flexibility. It sits right in the middle. It helps you to give structure to your app, lets you plug and play any package you like and doesn\'t get in the way to let you write code the way you like it. Lagoon road is laid back...</p>\n      <p>In Lagoon road, we turn everything in to middleware. Routing, templating, you name it. All this middleware is connected to a single object, which we call the <em>road</em>. You can picture it as a single road on an island. You can never get lost, it is either left or right. In Lagoon road it is even simpeler, it is a one way road.</p>\n      <p>Everything on the road is used by all environments that you are running, a web server, an API server, the client or even your Raspberry Pie/Aurdino and Mobile device. Because of this it becomes a breeze to share code among these environments and still keeping everything code wise DRY. Sharing routes between client and web server, have login checks for the api server and web server, sharing is how Lagoon road works best.</p>\n      <p>Lagoon road is not a monolithic framework that does everything out of the box. The core, and only mandatory package is less then 200 lines of code. You can add extensions (regular npm packages) to mold it in a system that works for you or your team. You remain in control over how to work and code.</p>\n      <section class="highlight">\n        <h2>Where from here?</h2>\n        <p>\n          <a href="/guide" class="pure-button">Examples in the <strong>guide</strong></a>\n          <a href="/reference" class="pure-button">Details in the <strong>reference</strong></a>\n          <a href="/faq" class="pure-button">Answers in the <strong>FAQ</strong></a>\n        </p>\n      </section>\n      <h2>Some <span class="laid-back">laid back</span> features of lagoon road</h2>\n      <ul class="features">\n        <li><span>1</span>It is modular, don\'t like a package, switch it for something else, it is all just npm packages, so plug and play the way you like</li>\n        <li><span>2</span>Websockets, HTTP(2), you can switch protocols without having to change the way you build your app</li>\n        <li><span>3</span>Plug in any store you like, you are not tied down to a single choice, you can even run multiple different ones next to each other</li>\n        <li><span>4</span>Share code between environments and keep it organized, even when you scale up</li>\n        <li><span>5</span>Want to hook up a Raspberry Pie or Arduino, sure thing, you can check for changes on sensory output and feed it straight into an api server, web server or straight to the browser</li>\n        <li><span>6</span>You know how middleware works? You are up and running for Lagoon road, no endless docs you have to plow through</li>\n      </ul>\n    </section>\n  ',"article");
next()}},{}],12:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n    <nav>\n      <ul>\n        <li><a href="/">Home</a></li>\n        <li><a href="/guide">Guide</a></li>\n        <li><a href="/reference">Reference</a></li>\n        <li><a href="/faq">Faq</a></li>\n      </ul>\n    </nav>\n  ',"#navigation");next()}},{}],13:[function(require,module,exports){"use strict";module.exports=function(next,relay,request){relay.extensions.renderer.render("\n    <h1>404 - Page not found</h1>\n    <pre>\n      Oh my, "+request.url+" could not be found\n    </pre>\n  ","article");next()}},{}],14:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n    <h1>Reference</h1>\n    <p>Although Lagoon road needs only a single package to be up and running, namely lr-core, it comes with additional packages that make it easy to do some common tasks, like routing and rendering.</p>\n    <ul class="submenu">\n      <li><a href="/reference/lr-core">lr-core</a></li>\n      <li><a href="/reference/lr-server-router">lr-server-router</a></li>\n      <li><a href="/reference/lr-server-renderer">lr-server-renderer</a></li>\n      <li><a href="/reference/lr-client-router">lr-client-router</a></li>\n      <li><a href="/reference/lr-client-renderer">lr-client-renderer</a></li>\n      <li><a href="/reference/lr-url-parser">lr-url-parser</a></li>\n    </ul>\n  ',"article");next()}},{}],15:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n        <h1 id="lg-client-renderer-reference">lg-client-renderer reference</h1>\n<p>A Lagoon road extension that gives you renderer functionality on the client. This renderer does quick replacement and doesn&#39;t do virtual dom html difference changes. It should suffice for about 95% of all cases. When you start working more with a websocket pub/sub system you might want to consider writing your own renderer or use a virtual dom approach so user input will not get replaced on dom updates. Read more about writing extensions in the <a href="https://www.lagoonroad.com/guide">guide</a>.</p>\n<table>\n<thead>\n<tr>\n<th>Information</th>\n<th>-</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Code coverage</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Repo link</td>\n<td><a href="https://github.com/lagoon-road/lr-client-renderer">lr-client-renderer</a></td>\n</tr>\n<tr>\n<td>Dependencies</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Size (Browserify, Babel, Uglify and Gzip)</td>\n<td>789 bytes</td>\n</tr>\n<tr>\n<td>Version</td>\n<td>1.0.0</td>\n</tr>\n<tr>\n<td>License</td>\n<td>MIT</td>\n</tr>\n<tr>\n<td>Usage</td>\n<td><a href="https://www.lagoonroad.com/guide">lagoonroad.com/guide</a></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id="adding-the-extension-to-lagoon-road">Adding the extension to lagoon road</h3>\n<pre><code><span class="hljs-attribute">const router</span>   = require(<span class="hljs-string">\'lg-client-renderer\'</span>);\n<span class="hljs-attribute">const core</span>     = require(<span class="hljs-string">\'lr-core\'</span>);\n<span class="hljs-attribute">const road</span>     = core(<span class="hljs-string">\'client\'</span>)\n  .extension(<span class="hljs-string">\'renderer\'</span>, renderer, true);\n</code></pre><hr>\n<h3 id="renderer-render-html-placeholder-">renderer.render(html, placeholder)</h3>\n<pre><code><span class="hljs-keyword">renderer</span>.<span class="hljs-keyword">render</span>(<span class="hljs-string">\'&lt;section&gt;...&lt;/section&gt;\'</span>, <span class="hljs-string">\'.placeholderName\'</span>);\n</code></pre><p><em>Prepare the component to be added to the template.</em></p>\n<p><strong>html:string</strong><br>The components html that you want to load.</p>\n<p><strong>placeholder:string</strong><br>A html selector that should be the parent of the html you want to add. The contents of the placeholder will be removed before adding the new html.</p>\n<hr>\n<h3 id="renderer-html-">renderer.html()</h3>\n<pre><code>renderer.html()<span class="hljs-comment">;</span>\n</code></pre><p><em>Replaces all the components that are added with <code>renderer.render</code> to the template at once. This way templates will only be added once even if they have been declared for replacement multiple times. </em></p>\n\n    ',"article");next()}},{}],16:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n        <h1 id="lg-client-router-reference">lg-client-router reference</h1>\n<p>A Lagoon road extension that gives you route functionality on the client.</p>\n<table>\n<thead>\n<tr>\n<th>Information</th>\n<th>-</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Code coverage</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Repo link</td>\n<td><a href="https://github.com/lagoon-road/lr-client-router">lr-client-router</a></td>\n</tr>\n<tr>\n<td>Dependencies</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Size (Browserify, Babel, Uglify and Gzip)</td>\n<td>612 bytes</td>\n</tr>\n<tr>\n<td>Version</td>\n<td>1.0.0</td>\n</tr>\n<tr>\n<td>License</td>\n<td>MIT</td>\n</tr>\n<tr>\n<td>Usage</td>\n<td><a href="https://www.lagoonroad.com/guide">lagoonroad.com/guide</a></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id="adding-the-extension-to-lagoon-road">Adding the extension to lagoon road</h3>\n<pre><code><span class="hljs-attribute">const router</span>   = require(<span class="hljs-string">\'lg-client-router\'</span>);\n<span class="hljs-attribute">const core</span>     = require(<span class="hljs-string">\'lr-core\'</span>);\n<span class="hljs-attribute">const road</span>     = core(<span class="hljs-string">\'client\'</span>)\n  .extension(<span class="hljs-string">\'router\'</span>, router, true);\n</code></pre><hr>\n<h3 id="router-redirect-path-">router.redirect(path)</h3>\n<pre><code><span class="hljs-selector-tag">router</span><span class="hljs-selector-class">.redirect</span>(<span class="hljs-string">\'/some-page\'</span>);\n</code></pre><p><strong>path:string</strong><br>The path to where you want to redirect, this will trigger an update event on the road.</p>\n<hr>\n\n    ',"article");next()}},{}],17:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n        <h1 id="lg-core-reference">lg-core reference</h1>\n<p>The <em>lr-core</em> package is the only mandatory package for Lagoon road. This package connects everything together, regardless of environment. There are eight exposed functions that you can use.</p>\n<table>\n<thead>\n<tr>\n<th>Information</th>\n<th>-</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Code coverage</td>\n<td><a href="https://coveralls.io/github/lagoon-road/lr-core?branch=master"><img src="https://coveralls.io/repos/github/lagoon-road/lr-core/badge.svg?branch=master" alt="Coverage Status"></a></td>\n</tr>\n<tr>\n<td>Repo link</td>\n<td><a href="https://github.com/lagoon-road/lr-core">lr-core</a></td>\n</tr>\n<tr>\n<td>Dependencies</td>\n<td><a href="https://github.com/philbooth/check-types.js">check-types</a>, <a href="https://github.com/lagoon-road/lr-url-parser">lr-url-parser</a></td>\n</tr>\n<tr>\n<td>Size (Browserify, Babel, Uglify and Gzip)</td>\n<td>5.3KB</td>\n</tr>\n<tr>\n<td>Version</td>\n<td>1.0.0</td>\n</tr>\n<tr>\n<td>License</td>\n<td>MIT</td>\n</tr>\n<tr>\n<td>Usage</td>\n<td><a href="https://www.lagoonroad.com/guide">lagoonroad.com/guide</a></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id="core-environmentid-options-">core(environmentId, [options])</h3>\n<pre><code><span class="hljs-attribute">const core</span> = require(<span class="hljs-string">\'lr-core\'</span>);\n<span class="hljs-attribute">const road</span> = core(<span class="hljs-string">\'webserver\'</span>);\n</code></pre><p><strong>environmentId:string</strong><br>The primary environment id for the road, this is the executing environment that will be used when an update cycle is fired.</p>\n<p><strong>[options.parser:object]</strong><br>The parser to use when handling the <em>matchValue</em>. Read more about parsers in the <a href="https://lagoonroad.com/guide#parsers">guide</a>.</p>\n<p><strong>[options.resetAfterCycle:boolean]</strong><br>By default the relay object gets cleared after an update cycle of the road, sometimes, mainly on the client, you want to keep the relay populated even if an update cycle has ran. To do so, you can set this boolean to  <em>false</em></p>\n<hr>\n<h3 id="road-extension-extensionid-extension-isupdater-">road.extension(extensionId, extension, [isUpdater])</h3>\n<pre><code>road.extension(<span class="hljs-string">\'router\'</span>, router, <span class="hljs-literal">true</span>);\n</code></pre><p><strong>extensionId:string</strong><br>A unique id to identify the extension.</p>\n<p><strong>extension:*</strong><br>The actual extension, this can be any type of code that you want to use</p>\n<p><strong>[isUpdater:boolean = false]</strong><br>Tell the core if on initialization the extension needs to be executed. This is typically for extensions that use update events to trigger updates to the road. Read more about <a href="https://lagoonroad.com/guide#extensions">extensions</a> in the guide.</p>\n<blockquote>\n<p>Extensions can be used in middleware via the relay object.</p>\n<pre><code><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">next</span>, relay)</span> =&gt;</span> {\n  console.log(relay.extensions.extensionName);\n  <span class="hljs-built_in">next</span>();\n}\n</code></pre></blockquote>\n<hr>\n<h3 id="road-middleware-middleware-">road.middleware(middleware)</h3>\n<pre><code>road.middleware({ bodyParser }, <span class="hljs-string">\'bodyParser\'</span>);\n</code></pre><p><strong>middleware:object</strong><br>An object with all the middleware you want to use. This is a single depth object so don&#39;t use any nested structures.</p>\n<blockquote>\n<p>Middleware methods can be called multiple times, the middleware will all be added to a single object within the core. Therefore you need to supply unique ids/keys.\nIf you have a multitude of middleware functions that you  want to use it might be handy to use a dot notation to  group your middleware.</p>\n<pre><code>road.middleware({\n  <span class="hljs-string">\'templating.component.navigation\'</span> : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'...\'</span>),  \n  <span class="hljs-string">\'templating.component.home\'</span>       : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'...\'</span>),  \n});\n</code></pre><p>Read more about how to define and use middleware in the <a href="https://lagoonroad.com/guide#middleware">guide</a>.</p>\n</blockquote>\n<hr>\n<h3 id="road-where-environmentid-environmentid-">road.where(environmentId, [...environmentId])</h3>\n<pre><code>road.<span class="hljs-keyword">where</span>(<span class="hljs-string">\'webserver\'</span>, <span class="hljs-string">\'client\'</span>);\n</code></pre><p><em>When assigning middleware to the road you might want to switch the environment they need to be assigned to. You can do that by using the <code>where</code> method.</em></p>\n<p><strong>environmentId:string</strong><br>The where method expects at least one argument, which should be a string. This is an environment id to which all the following middleware will be assigned. If you want to assign middleware to multiple environments you can just specify several ids like in the example above.</p>\n<hr>\n<h3 id="road-run-matchvalue-middlewareid-matchvalue-">road.run(matchValue, middlewareId, [matchValue])</h3>\n<pre><code>road.<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'log\'</span>);\n</code></pre><p><strong>matchValue:string</strong><br>A match value in most webapps can be thought of as an url path, but it is not limited to paths only. Frankly it can be any string you can think of, even a JSON string to match on JSON content. Or in an even more exotic example you can match Raspberry pie sensor outputs via an extension to string values and let that trigger middleware. You can use the <code>*</code> as a wildcard to match on all match values that might come in.</p>\n<p><strong>middlewareId:string</strong><br>Identifier you added by using the <code>middleware</code> method. It needs to be a string and should match to a middleware function, otherwise it will throw.</p>\n<p><strong>[updateType:string]</strong><br>The update type is an extra layer for matching middleware, if we use a http protocol to update the road, this will be the method for the request. By default it wil be <code>GET</code> because it is the most common, but it can be overwritten to be something else. Again you are not limited to http methods, it fully depends on what an extension sends out via an update event.</p>\n<hr>\n<h3 id="road-error-middlewareid-updatetype-">road.error(middlewareId, [updateType])</h3>\n<pre><code>road.<span class="hljs-keyword">error</span>(\'<span class="hljs-built_in">log</span>\')\n</code></pre><p><em>Whenever the stack of middleware that is updated throws an error, it will be redirected to error middleware. You can use it to render alternative content or log the errors. The <code>relay</code> object will have a new property <code>relay.error</code> with the error message.</em></p>\n<p><strong>middlewareId:string</strong><br>Identifier you added by using the <code>middleware</code> method. It needs to be a string and should match to a middleware function, otherwise it will throw.</p>\n<p><strong>[updateType:string]</strong><br>The update type is an extra layer for matching middleware, if we use a http protocol to update the road, this will be the method for the request. By default it wil be <code>GET</code> because it is the most common, but it can be overwritten to be something else. Again you are not limited to http methods, it fully depends on what an extension sends out via an update event.</p>\n<hr>\n<h3 id="road-nomatch-middlewareid-updatetype-">road.noMatch(middlewareId, [updateType])</h3>\n<pre><code><span class="hljs-selector-tag">road</span><span class="hljs-selector-class">.noMatch</span>(<span class="hljs-string">\'log\'</span>);\n</code></pre><p><em>When no middleware could be found for a current combination of <code>matchValue</code> and <code>updateType</code>, the <code>noMatch</code> middleware will be called, this is handy if you want to return a 404 page or something similar.</em></p>\n<p><strong>middlewareId:string</strong><br>Identifier you added by using the <code>middleware</code> method. It needs to be a string and should match to a middleware function, otherwise it will throw.</p>\n<p><strong>[updateType:string]</strong><br>The update type is an extra layer for matching middleware, if we use a http protocol to update the road, this will be the method for the request. By default it wil be <code>GET</code> because it is the most common, but it can be overwritten to be something else. Again you are not limited to http methods, it fully depends on what an extension sends out via an update event.</p>\n<hr>\n<h3 id="road-done-middlewareid-updatetype-">road.done(middlewareId, [updateType])</h3>\n<pre><code><span class="hljs-selector-tag">road</span><span class="hljs-selector-class">.done</span>(<span class="hljs-string">\'response\'</span>, <span class="hljs-string">\'post\'</span>);\n</code></pre><p><em>The <code>done</code> method is called as the last method in the stack, it is typically used to render output (html or json) to a client</em></p>\n<p><strong>middlewareId:string</strong><br>Identifier you added by using the <code>middleware</code> method. It needs to be a string and should match to a middleware function, otherwise it will throw.</p>\n<p><strong>[updateType:string]</strong><br>The update type is an extra layer for matching middleware, if we use a http protocol to update the road, this will be the method for the request. By default it wil be <code>GET</code> because it is the most common, but it can be overwritten to be something else. Again you are not limited to http methods, it fully depends on what an extension sends out via an update event.</p>\n<hr>\n<h3 id="road-update-options-object-parameters-">road.update(options:object, [...parameters])</h3>\n<pre><code><span class="hljs-selector-tag">road</span><span class="hljs-selector-class">.update</span>({ <span class="hljs-attribute">matchValue </span>: <span class="hljs-string">\'/somepath\'</span>, updateType : <span class="hljs-string">\'post\'</span> }, <span class="hljs-selector-tag">parameterOne</span>, <span class="hljs-selector-tag">parameterTwo</span>);\n</code></pre><p><em>Manually trigger an upadte cycle to the road by calling the <code>update</code> method.</em></p>\n<p><strong>options.matchValue:string</strong><br>A match value in most webapps can be thought of as an url path, but it is not limited to paths only. Frankly it can be any string you can think of, even a JSON string to match on JSON content. Or in an even more exotic example you can match Raspberry pie sensor outputs via an extension to string values and let that trigger middleware. You can use the <code>*</code> as a wildcard to match on all match values that might come in.</p>\n<p><strong>options.updateType:string</strong><br>The update type is an extra layer for matching middleware, if we use a http protocol to update the road, this will be the method for the request. By default it wil be <code>GET</code> because it is the most common, but it can be overwritten to be something else. Again you are not limited to http methods, it fully depends on what an extension sends out via an update event.</p>\n<p><strong>parameters:*</strong><br>Each update can be have custom parameters that will be available as middleware arguments. This could be for example the <code>request</code> and <code>response</code> object on a router update.</p>\n<blockquote>\n<p>Read more about parameters in the <a href="https://lagoonroad.com/guide#middleware">middleware</a> section.\nEvery time a update method is called the middleware that matches will be added to the stack of middleware that needs to be executed. So when calling this on the server you might send out a response and afterwards more middleware will be called. Therefore use it on the client mainly to initialize events. Make sure you fully understand the middelware stack before start using the update function.</p>\n</blockquote>\n\n    ',"article");next()}},{}],18:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n        <h1 id="lg-server-renderer-reference">lg-server-renderer reference</h1>\n<p>Server side renderer for lagoon road.</p>\n<table>\n<thead>\n<tr>\n<th>Information</th>\n<th>-</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Code coverage</td>\n<td><a href="https://coveralls.io/github/lagoon-road/lr-server-renderer?branch=master"><img src="https://coveralls.io/repos/github/lagoon-road/lr-server-renderer/badge.svg?branch=master" alt="Coverage Status"></a></td>\n</tr>\n<tr>\n<td>Repo link</td>\n<td><a href="https://github.com/lagoon-road/lr-server-renderer">lr-core</a></td>\n</tr>\n<tr>\n<td>Dependencies</td>\n<td><a href="https://github.com/cheeriojs/cheerio">cheerio</a></td>\n</tr>\n<tr>\n<td>Size (ex. dependencies)</td>\n<td>612 bytes</td>\n</tr>\n<tr>\n<td>Version</td>\n<td>1.0.0</td>\n</tr>\n<tr>\n<td>License</td>\n<td>MIT</td>\n</tr>\n<tr>\n<td>Usage</td>\n<td><a href="https://www.lagoonroad.com/guide">lagoonroad.com/guide</a></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id="renderer-template-html-">renderer.template(html)</h3>\n<pre><code>renderer.template(<span class="hljs-comment">\'<span class="hljs-doctag">&lt;html&gt;</span>...<span class="hljs-doctag">&lt;/html&gt;</span>\');</span>\n</code></pre><p><em>Method sets the template for the output, all components will be added to this template</em></p>\n<p><strong>html:string</strong><br>The template you want to use for the components and state that you might want to add.</p>\n<hr>\n<h3 id="renderer-render-html-placeholder-">renderer.render(html, placeholder)</h3>\n<pre><code><span class="hljs-keyword">renderer</span>.<span class="hljs-keyword">render</span>(<span class="hljs-string">\'&lt;section&gt;...&lt;/section&gt;\'</span>, <span class="hljs-string">\'.placeholderName\'</span>);\n</code></pre><p><em>Adds a component to the template.</em></p>\n<p><strong>html:string</strong><br>The components html that you want to load.</p>\n<p><strong>placeholder:string</strong><br>A html selector that should be the parent of the html you want to add. The contents of the placeholder will be removed before adding the new html.</p>\n<hr>\n<h3 id="renderer-state-state-">renderer.state(state)</h3>\n<pre><code><span class="hljs-selector-tag">renderer</span><span class="hljs-selector-class">.state</span>({ <span class="hljs-attribute">data </span>: [...], otherProperties : true });\n</code></pre><p><em>Add data to a script tag that you can access on the client again. This prevents loading the same data. The data will be available by accessing <code>window.__state__</code> as json.</em></p>\n<p><strong>state:object</strong><br>An object that has been loaded on the server that you want to transfer to the client.</p>\n<hr>\n<h3 id="renderer-html-">renderer.html()</h3>\n<pre><code>renderer.html()<span class="hljs-comment">;</span>\n</code></pre><p><em>Get the final output of the template and components that you have created, this data can be send back as the response to the client.</em></p>\n\n    ',"article");next()}},{}],19:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n        <h1 id="lg-server-router-reference">lg-server-router reference</h1>\n<p>A Lagoon road extension that gives you route functionality on the server.</p>\n<table>\n<thead>\n<tr>\n<th>Information</th>\n<th>-</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Code coverage</td>\n<td><a href="https://coveralls.io/github/lagoon-road/lr-server-router?branch=master"><img src="https://coveralls.io/repos/github/lagoon-road/lr-server-router/badge.svg?branch=master" alt="Coverage Status"></a></td>\n</tr>\n<tr>\n<td>Repo link</td>\n<td><a href="https://github.com/lagoon-road/lr-server-router">lr-server-router</a></td>\n</tr>\n<tr>\n<td>Dependencies</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Size</td>\n<td>336 bytes</td>\n</tr>\n<tr>\n<td>Version</td>\n<td>1.0.0</td>\n</tr>\n<tr>\n<td>License</td>\n<td>MIT</td>\n</tr>\n<tr>\n<td>Usage</td>\n<td><a href="https://www.lagoonroad.com/guide">lagoonroad.com/guide</a></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id="function-initialization">Function initialization</h3>\n<p>This package doesn&#39;t have any exposed methods, it does however needs a single argument on creation.</p>\n<pre><code><span class="hljs-attribute">const protocol</span> = require(<span class="hljs-string">\'http\'</span>);\n<span class="hljs-attribute">const server</span>   = protocol.createServer();\n<span class="hljs-attribute">const router</span>   = require(<span class="hljs-string">\'lg-server-router\'</span>)(server);\n<span class="hljs-attribute">const core</span>     = require(<span class="hljs-string">\'lr-core\'</span>);\n<span class="hljs-attribute">const road</span>     = core(<span class="hljs-string">\'webserver\'</span>)\n  .extension(<span class="hljs-string">\'router\'</span>, router, true);\n</code></pre><hr>\n\n    ',"article");next()}},{}],20:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n        <p><a href="https://coveralls.io/github/lagoon-road/lr-url-parser?branch=master"><img src="https://coveralls.io/repos/github/lagoon-road/lr-url-parser/badge.svg?branch=master" alt="Coverage Status"></a></p>\n<h1 id="lr-url-parser">lr-url-parser</h1>\n<p>Parser that can take placeholders from urls and match them with real urls</p>\n\n    ',"article");next()}},{}],21:[function(require,module,exports){"use strict";module.exports=function(next,relay){var logo=document.querySelector(".logo");var content=document.querySelector(".content");if(window.location.pathname==="/"){logo.classList.remove("compact");content.classList.remove("compact")}else{logo.classList.add("compact");content.classList.add("compact")}function resize(){document.querySelector(".animations").style.height=0;document.querySelector(".animations").style.height=document.querySelector("body").scrollHeight+"px"}window.resize=function(){resize()};resize();next()}},{}]},{},[6]);
