(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){module.exports=(update=>{let placeholders={};function addObserver(id){const observer=new MutationObserver(function(mutations){mutations.forEach(function(mutation){if(mutation.attributeName==="lg-placeholder"){update({matchValue:id,updateType:"domReady"})}})});observer.observe(document.querySelector(id),{attributes:true,childList:false,subtree:false});placeholders[id].observer=observer}const exposed={render(html,id){if(placeholders[id]&&placeholders[id].observer){placeholders[id].observer.disconnect()}placeholders[id]={html:html}},html(){Object.keys(placeholders).filter(id=>placeholders[id].html).forEach(id=>{if(!document.querySelector(id)){throw new Error(`Trying to render, but could not find placeholder ${id}`)}addObserver(id);document.querySelector(id).innerHTML=placeholders[id].html;document.querySelector(id).setAttribute("lg-placeholder",id);delete placeholders[id].html})}};return exposed})},{}],2:[function(require,module,exports){module.exports=(update=>{document.addEventListener("click",event=>{if(event.target.nodeName.toLowerCase()==="a"&&event.target.getAttribute("href")&&event.target.getAttribute("href")[0]==="/"){event.preventDefault();const url=event.target.getAttribute("href");history.pushState({url:url},url,url);update({matchValue:url},{url:url})}});window.onpopstate=function(request){if(request&&request.state&&request.state.url){update({matchValue:request.state.url},request.state)}};return{redirect(url){history.pushState({url:url},url,url);update({matchValue:url},{url:url})}}})},{}],3:[function(require,module,exports){const check=require("check-types");module.exports=((environmentId,options={})=>{const defaultUpdateType="get";let middlewareStack=[];let updateStack=[];let relay;let selectedParser={add:()=>{},parse:matchValue=>{return{path:matchValue,parameters:{}}}};let resetAfterCycle=true;let traditional=[];let extensions={};let availableMiddleware={};let executingEnvironmentId=environmentId;let selectedEnvironmentIds=[environmentId];let environments={};const exposed={extension:extension,middleware:middleware,where:where,run:run,error:error,noMatch:noMatch,done:done,update:update,parser:parser};if(options.resetAfterCycle!==undefined){check.assert.boolean(options.resetAfterCycle,"resetAfterCycle needs to be a boolean");resetAfterCycle=options.resetAfterCycle}environments[environmentId]=environment(environmentId);function parser(parser){check.assert.function(parser.add,'Parser needs to have a method called "add"');check.assert.function(parser.parse,'Parser needs to have a method called "parse"');selectedParser=parser}function environment(id){check.assert.not.undefined(id,"Environment id cannot be empty");check.assert.match(id,/^[a-z0-9]+$/i,"Environment id needs to be a string containing only letters and or numbers");return{id:id,matches:{},middleware:[],noMatch:[],error:[],done:[]}}function extension(id,extension,isUpdater=false){check.assert.not.undefined(id,"Extension id cannot be empty");check.assert.not.undefined(extension,"Extension cannot be empty");check.assert.match(id,/^[a-z0-9]+$/i,"Extension id needs to be a string containing only letters and or numbers");check.assert.not.assigned(extensions[id],`"${id}" has already been defined as an extension`);extensions[id]=isUpdater?extension(update):extension;return exposed}function middleware(newMiddleware,...traditionals){check.assert.nonEmptyObject(newMiddleware,"Provided middleware needs to be a non empty object");Object.keys(newMiddleware).forEach(id=>{check.assert.not.assigned(availableMiddleware[id],`"${id}" has already been defined as middleware`);check.assert.function(newMiddleware[id],`"${id}" middleware is not a function`)});if(traditionals.length){check.assert.array.of.string(traditionals,"All traditional middleware names need to be strings");traditionals.forEach((id,index)=>{check.assert.equal(traditionals.indexOf(id),index,`Duplicate values found for traditional middleware "${id}"`);check.assert.equal(traditional.indexOf(id),-1,`"${id}" has already been defined as a traditional middleware function`)});traditional=[...traditional,...traditionals]}availableMiddleware=Object.assign({},availableMiddleware,newMiddleware);return exposed}function where(...environmentIds){check.assert.greater(environmentIds.length,0,"Where method missing parameters");environmentIds.forEach(id=>{check.assert.not.undefined(id,"Environment id cannot be empty");check.assert.match(id,/^[a-z0-9]+$/i,"Environment id needs to be a string containing only letters and or numbers");if(!environments[id]){environments[id]=environment(id)}});selectedEnvironmentIds=environmentIds;return exposed}function run(matchValue,middlewareId,updateType=defaultUpdateType){check.assert.not.undefined(matchValue,"Match value cannot be empty");check.assert.string(matchValue,"Match value needs to be a string");check.assert.not.undefined(middlewareId,"Middleware id cannot be empty");check.assert.match(middlewareId,/^[a-z0-9\.]+$/i,'Middleware id needs to be a string containing only letters,numbers and an optional "."');check.assert.match(updateType,/^[a-z0-9]+$/i,"Update type needs to be a string containing only letters and or numbers");selectedParser.add(matchValue);selectedEnvironmentIds.forEach(environmentId=>{environments[environmentId].middleware.push({matchValue:matchValue,id:middlewareId,updateType:updateType.toLowerCase()})});return exposed}function error(middlewareId,updateType=defaultUpdateType){check.assert.zero(arguments.length-1,"Error needs exactly one argument");check.assert.match(middlewareId,/^[a-z0-9\.]+$/i,'Middleware id needs to be a string containing only letters,numbers and an optional "."');selectedEnvironmentIds.forEach(id=>environments[id].error.push({id:middlewareId,updateType:updateType}));return exposed}function noMatch(middlewareId,updateType=defaultUpdateType){check.assert.zero(arguments.length-1,"NoMatch needs exactly one argument");check.assert.match(middlewareId,/^[a-z0-9\.]+$/i,'Middleware id needs to be a string containing only letters,numbers and an optional "."');selectedEnvironmentIds.forEach(id=>environments[id].noMatch.push({id:middlewareId,updateType:updateType}));return exposed}function done(middlewareId,updateType=defaultUpdateType){check.assert.zero(arguments.length-1,"Done needs exactly one argument");check.assert.match(middlewareId,/^[a-z0-9\.]+$/i,'Middleware id needs to be a string containing only letters,numbers and an optional "."');selectedEnvironmentIds.forEach(id=>environments[id].done.push({id:middlewareId,updateType:updateType}));return exposed}function update(options,...parameters){updateStack.push({options:options,parameters:parameters});if(middlewareStack.length===0){runMiddlewareStack()}return exposed}function exit(){middlewareStack=[];runMiddlewareStack()}function prepareRelay(parameters){if(!relay||resetAfterCycle){relay=Object.assign({extensions:extensions,update:update,exit:exit},parameters)}else{relay=Object.assign({},relay,parameters)}}function runMiddlewareStack(){const update=updateStack.shift();if(update){function thunkifyMiddleware(currentMiddleware){if(!currentMiddleware){return()=>{}}const id=currentMiddleware.id;const callback=availableMiddleware[id];check.assert.assigned(callback,`Middleware ${id} not found`);check.assert.function(callback,"Middleware needs to be a function");return function(defined={}){check.assert.object(defined,"Relay additions need to be an object");if(defined.extensions){throw new Error("Cannot assign extensions as a relay property, this is a reserved property")}if(defined.exit){throw new Error("Cannot assign exit as a relay property, this is a reserved property")}if(defined.update){throw new Error("Cannot assign update as a relay property, this is a reserved property")}relay=Object.assign({},relay,defined);const next=middlewareStack.length===0?()=>{}:thunkifyMiddleware(middlewareStack.shift());let parameters=[next,relay,...update.parameters];if(traditional.indexOf(id)>-1&&relay.error){parameters=[...update.parameters,next,relay.error]}else if(traditional.indexOf(id)>-1){parameters=[...update.parameters,next]}callback(...parameters);if(middlewareStack.length===0){runMiddlewareStack()}}}function getMiddleware(type){let output;const environment=environments[executingEnvironmentId];if(type==="match"){output=environment.middleware.filter(record=>record.matchValue===matchValue.path||record.matchValue==="*").filter(record=>record.updateType===updateType)}else{output=environment[type].filter(middleware=>middleware.updateType===updateType)}if(output.length===0&&(type==="match"||type==="error")){console.warn(`No ${type==="match"?"":'"'+type+'"'} middleware found for matchValue: ${matchValue.path}, updateType: ${updateType}`)}return output}check.assert.assigned(update.options.matchValue,"Update function cannot find a matchValue");const matchValue=selectedParser.parse(update.options.matchValue);const updateType=update.options.updateType?update.options.updateType.toLowerCase():defaultUpdateType;try{prepareRelay({parameters:matchValue.parameters});middlewareStack=getMiddleware("match");if(middlewareStack.length===0){middlewareStack=getMiddleware("noMatch")}middlewareStack=[...middlewareStack,...getMiddleware("done")];thunkifyMiddleware(middlewareStack.shift())();return exposed}catch(error){prepareRelay({error:error});middlewareStack=getMiddleware("error");if(middlewareStack.length===0){console.error(error)}middlewareStack=[...middlewareStack,...getMiddleware("done")];thunkifyMiddleware(middlewareStack.shift())()}}}return exposed})},{"check-types":4}],4:[function(require,module,exports){(function(globals){"use strict";var strings,messages,predicates,functions,assert,not,maybe,collections,slice;strings={v:"value",n:"number",s:"string",b:"boolean",o:"object",t:"type",a:"array",al:"array-like",i:"iterable",d:"date",f:"function",l:"length"};messages={};predicates={};[{n:"equal",f:equal,s:"v"},{n:"undefined",f:isUndefined,s:"v"},{n:"null",f:isNull,s:"v"},{n:"assigned",f:assigned,s:"v"},{n:"includes",f:includes,s:"v"},{n:"zero",f:zero},{n:"infinity",f:infinity},{n:"number",f:number},{n:"integer",f:integer},{n:"even",f:even},{n:"odd",f:odd},{n:"greater",f:greater},{n:"less",f:less},{n:"between",f:between},{n:"greaterOrEqual",f:greaterOrEqual},{n:"lessOrEqual",f:lessOrEqual},{n:"inRange",f:inRange},{n:"positive",f:positive},{n:"negative",f:negative},{n:"string",f:string,s:"s"},{n:"emptyString",f:emptyString,s:"s"},{n:"nonEmptyString",f:nonEmptyString,s:"s"},{n:"contains",f:contains,s:"s"},{n:"match",f:match,s:"s"},{n:"boolean",f:boolean,s:"b"},{n:"object",f:object,s:"o"},{n:"emptyObject",f:emptyObject,s:"o"},{n:"nonEmptyObject",f:nonEmptyObject,s:"o"},{n:"instanceStrict",f:instanceStrict,s:"t"},{n:"instance",f:instance,s:"t"},{n:"like",f:like,s:"t"},{n:"array",f:array,s:"a"},{n:"emptyArray",f:emptyArray,s:"a"},{n:"nonEmptyArray",f:nonEmptyArray,s:"a"},{n:"arrayLike",f:arrayLike,s:"al"},{n:"iterable",f:iterable,s:"i"},{n:"date",f:date,s:"d"},{n:"function",f:isFunction,s:"f"},{n:"hasLength",f:hasLength,s:"l"}].map(function(data){var n=data.n;messages[n]="Invalid "+strings[data.s||"n"];predicates[n]=data.f});functions={apply:apply,map:map,all:all,any:any};collections=["array","arrayLike","iterable","object"];slice=Array.prototype.slice;functions=mixin(functions,predicates);assert=createModifiedPredicates(assertModifier,assertImpl);not=createModifiedPredicates(notModifier,notImpl);maybe=createModifiedPredicates(maybeModifier,maybeImpl);assert.not=createModifiedModifier(assertModifier,not);assert.maybe=createModifiedModifier(assertModifier,maybe);collections.forEach(createOfPredicates);createOfModifiers(assert,assertModifier);createOfModifiers(not,notModifier);collections.forEach(createMaybeOfModifiers);exportFunctions(mixin(functions,{assert:assert,not:not,maybe:maybe}));function equal(lhs,rhs){return lhs===rhs}function isUndefined(data){return data===undefined}function isNull(data){return data===null}function assigned(data){return!isUndefined(data)&&!isNull(data)}function zero(data){return data===0}function infinity(data){return data===Number.POSITIVE_INFINITY||data===Number.NEGATIVE_INFINITY}function number(data){return typeof data==="number"&&isNaN(data)===false&&data!==Number.POSITIVE_INFINITY&&data!==Number.NEGATIVE_INFINITY}function integer(data){return number(data)&&data%1===0}function even(data){return number(data)&&data%2===0}function odd(data){return integer(data)&&!even(data)}function greater(lhs,rhs){return number(lhs)&&lhs>rhs}function less(lhs,rhs){return number(lhs)&&lhs<rhs}function between(data,x,y){if(x<y){return greater(data,x)&&less(data,y)}return less(data,x)&&greater(data,y)}function greaterOrEqual(lhs,rhs){return number(lhs)&&lhs>=rhs}function lessOrEqual(lhs,rhs){return number(lhs)&&lhs<=rhs}function inRange(data,x,y){if(x<y){return greaterOrEqual(data,x)&&lessOrEqual(data,y)}return lessOrEqual(data,x)&&greaterOrEqual(data,y)}function positive(data){return greater(data,0)}function negative(data){return less(data,0)}function string(data){return typeof data==="string"}function emptyString(data){return data===""}function nonEmptyString(data){return string(data)&&data!==""}function contains(data,substring){return string(data)&&data.indexOf(substring)!==-1}function match(data,regex){return string(data)&&!!data.match(regex)}function boolean(data){return data===false||data===true}function object(data){return Object.prototype.toString.call(data)==="[object Object]"}function emptyObject(data){return object(data)&&Object.keys(data).length===0}function nonEmptyObject(data){return object(data)&&Object.keys(data).length>0}function instanceStrict(data,prototype){try{return data instanceof prototype}catch(error){return false}}function instance(data,prototype){try{return instanceStrict(data,prototype)||data.constructor.name===prototype.name||Object.prototype.toString.call(data)==="[object "+prototype.name+"]"}catch(error){return false}}function like(data,archetype){var name;for(name in archetype){if(archetype.hasOwnProperty(name)){if(data.hasOwnProperty(name)===false||typeof data[name]!==typeof archetype[name]){return false}if(object(data[name])&&like(data[name],archetype[name])===false){return false}}}return true}function array(data){return Array.isArray(data)}function emptyArray(data){return array(data)&&data.length===0}function nonEmptyArray(data){return array(data)&&data.length>0}function arrayLike(data){return assigned(data)&&number(data.length)}function iterable(data){if(typeof Symbol==="undefined"){return arrayLike(data)}return assigned(data)&&isFunction(data[Symbol.iterator])}function includes(data,value){var iterator,iteration;if(not.assigned(data)){return false}try{if(typeof Symbol!=="undefined"&&data[Symbol.iterator]&&isFunction(data.values)){iterator=data.values();do{iteration=iterator.next();if(iteration.value===value){return true}}while(!iteration.done);return false}Object.keys(data).forEach(function(key){if(data[key]===value){throw 0}})}catch(ignore){return true}return false}function hasLength(data,length){return assigned(data)&&data.length===length}function date(data){try{return instance(data,Date)&&integer(data.getTime())}catch(error){return false}}function isFunction(data){return typeof data==="function"}function apply(data,predicates){assert.array(data);if(isFunction(predicates)){return data.map(function(value){return predicates(value)})}assert.array(predicates);assert.hasLength(data,predicates.length);return data.map(function(value,index){return predicates[index](value)})}function map(data,predicates){assert.object(data);if(isFunction(predicates)){return mapSimple(data,predicates)}assert.object(predicates);return mapComplex(data,predicates)}function mapSimple(data,predicate){var result={};Object.keys(data).forEach(function(key){result[key]=predicate(data[key])});return result}function mapComplex(data,predicates){var result={};Object.keys(predicates).forEach(function(key){var predicate=predicates[key];if(isFunction(predicate)){if(not.assigned(data)){result[key]=!!predicate.m}else{result[key]=predicate(data[key])}}else if(object(predicate)){result[key]=mapComplex(data[key],predicate)}});return result}function all(data){if(array(data)){return testArray(data,false)}assert.object(data);return testObject(data,false)}function testArray(data,result){var i;for(i=0;i<data.length;i+=1){if(data[i]===result){return result}}return!result}function testObject(data,result){var key,value;for(key in data){if(data.hasOwnProperty(key)){value=data[key];if(object(value)&&testObject(value,result)===result){return result}if(value===result){return result}}}return!result}function any(data){if(array(data)){return testArray(data,true)}assert.object(data);return testObject(data,true)}function mixin(target,source){Object.keys(source).forEach(function(key){target[key]=source[key]});return target}function assertModifier(predicate,defaultMessage){return function(){assertPredicate(predicate,arguments,defaultMessage)}}function assertPredicate(predicate,args,defaultMessage){var argCount=predicate.l||predicate.length;var message=args[argCount];var ErrorType=args[argCount+1];assertImpl(predicate.apply(null,args),nonEmptyString(message)?message:defaultMessage,isFunction(ErrorType)?ErrorType:TypeError)}function assertImpl(value,message,ErrorType){if(value===false){throw new(ErrorType||Error)(message||"Assertion failed")}}function notModifier(predicate){var modifiedPredicate=function(){return notImpl(predicate.apply(null,arguments))};modifiedPredicate.l=predicate.length;return modifiedPredicate}function notImpl(value){return!value}function maybeModifier(predicate){var modifiedPredicate=function(){if(not.assigned(arguments[0])){return true}return predicate.apply(null,arguments)};modifiedPredicate.l=predicate.length;modifiedPredicate.m=true;return modifiedPredicate}function maybeImpl(value){if(assigned(value)===false){return true}return value}function ofModifier(target,type,predicate){var modifiedPredicate=function(){var collection,args;collection=arguments[0];if(target==="maybe"&&not.assigned(collection)){return true}if(!type(collection)){return false}collection=coerceCollection(type,collection);args=slice.call(arguments,1);try{collection.forEach(function(item){if((target!=="maybe"||assigned(item))&&!predicate.apply(null,[item].concat(args))){throw 0}})}catch(ignore){return false}return true};modifiedPredicate.l=predicate.length;return modifiedPredicate}function coerceCollection(type,collection){switch(type){case arrayLike:return slice.call(collection);case object:return Object.keys(collection).map(function(key){return collection[key]});default:return collection}}function createModifiedPredicates(modifier,object){return createModifiedFunctions([modifier,predicates,object])}function createModifiedFunctions(args){var modifier,object,functions,result;modifier=args.shift();object=args.pop();functions=args.pop();result=object||{};Object.keys(functions).forEach(function(key){Object.defineProperty(result,key,{configurable:false,enumerable:true,writable:false,value:modifier.apply(null,args.concat(functions[key],messages[key]))})});return result}function createModifiedModifier(modifier,modified){return createModifiedFunctions([modifier,modified,null])}function createOfPredicates(key){predicates[key].of=createModifiedFunctions([ofModifier.bind(null,null),predicates[key],predicates,null])}function createOfModifiers(base,modifier){collections.forEach(function(key){base[key].of=createModifiedModifier(modifier,predicates[key].of)})}function createMaybeOfModifiers(key){maybe[key].of=createModifiedFunctions([ofModifier.bind(null,"maybe"),predicates[key],predicates,null]);assert.maybe[key].of=createModifiedModifier(assertModifier,maybe[key].of);assert.not[key].of=createModifiedModifier(assertModifier,not[key].of)}function exportFunctions(functions){if(typeof define==="function"&&define.amd){define(function(){return functions})}else if(typeof module!=="undefined"&&module!==null&&module.exports){module.exports=functions}else{globals.check=functions}}})(this)},{}],5:[function(require,module,exports){"use strict";document.addEventListener("DOMContentLoaded",function(event){var router=require("lr-client-router");var renderer=require("lr-client-renderer");var road=require("lr-core")("client");road.extension("router",router,true).extension("renderer",renderer,true).middleware({"response.html":function responseHtml(next,relay){relay.extensions.renderer.html()},"events.navigation":require("../middleware/events/navigation")});require("./road")(road).where("client").update({matchValue:window.location.pathname,updateType:"domReady"})})},{"../middleware/events/navigation":26,"./road":6,"lr-client-renderer":1,"lr-client-router":2,"lr-core":3}],6:[function(require,module,exports){"use strict";module.exports=function(road){road.where("webserver","client").middleware({debug:function debug(next,relay,request){console.log(request.url);next()},"components.navigation":require("../middleware/components/navigation"),"components.home":require("../middleware/components/home"),"components.reference":require("../middleware/components/reference"),"components.lrCore":require("../middleware/components/reference/lrCore"),"components.lrServerRouter":require("../middleware/components/reference/lrServerRouter"),"components.lrServerRenderer":require("../middleware/components/reference/lrServerRenderer"),"components.lrClientRouter":require("../middleware/components/reference/lrClientRouter"),"components.lrClientRenderer":require("../middleware/components/reference/lrClientRenderer"),"components.lrUrlParser":require("../middleware/components/reference/lrUrlParser"),"components.faq":require("../middleware/components/faq"),"components.guide":require("../middleware/components/guide"),"components.guideSetup":require("../middleware/components/guide/setup"),"components.guideHelloWorld":require("../middleware/components/guide/helloWorld"),"components.guideAddingServerSideRenderer":require("../middleware/components/guide/addingServerSideRenderer"),"components.guideHandlingStaticContent":require("../middleware/components/guide/handlingStaticContent"),"components.guideMakeASinglePageApp":require("../middleware/components/guide/makeASinglePageApp"),"components.guideWorkingWithDOMEvents":require("../middleware/components/guide/workingWithDOMEvents"),"components.error":require("../middleware/components/error"),"components.noMatch":require("../middleware/components/noMatch")}).run("*","debug").where("webserver").run("*","layouts.default").run("*","components.navigation").noMatch("layouts.default").where("client").run("*","events.navigation","domReady").where("webserver","client").run("/","components.home").run("/guide","components.guide").run("/guide/setup","components.guideSetup").run("/guide/hello-world","components.guideHelloWorld").run("/guide/adding-server-side-renderer","components.guideAddingServerSideRenderer").run("/guide/handling-static-content","components.guideHandlingStaticContent").run("/guide/make-a-single-page-app","components.guideMakeASinglePageApp").run("/guide/working-with-dom-events","components.guideWorkingWithDOMEvents").run("/reference","components.reference").run("/reference/lr-core","components.lrCore").run("/reference/lr-server-router","components.lrServerRouter").run("/reference/lr-server-renderer","components.lrServerRenderer").run("/reference/lr-client-router","components.lrClientRouter").run("/reference/lr-client-renderer","components.lrClientRenderer").run("/reference/lr-url-parser","components.lrUrlParser").run("/faq","components.faq").noMatch("components.noMatch").error("components.error").done("response.html");return road}},{"../middleware/components/error":7,"../middleware/components/faq":8,"../middleware/components/guide":12,"../middleware/components/guide/addingServerSideRenderer":9,"../middleware/components/guide/handlingStaticContent":10,"../middleware/components/guide/helloWorld":11,"../middleware/components/guide/makeASinglePageApp":13,"../middleware/components/guide/setup":14,"../middleware/components/guide/workingWithDOMEvents":15,"../middleware/components/home":16,"../middleware/components/navigation":17,"../middleware/components/noMatch":18,"../middleware/components/reference":19,"../middleware/components/reference/lrClientRenderer":20,"../middleware/components/reference/lrClientRouter":21,"../middleware/components/reference/lrCore":22,"../middleware/components/reference/lrServerRenderer":23,"../middleware/components/reference/lrServerRouter":24,"../middleware/components/reference/lrUrlParser":25}],7:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render("\n    <h1>Error</h1>\n    <pre>"+relay.error+"</pre>\n  ","article");next()}},{}],8:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n        <h1 id="faq">Faq</h1>\n<p>Answers to some common questions you might have. Cannot find an answer? Please open an <a href="https://github.com/lagoon-road/lr-core/issues/new">issue</a> on Github. I will keep this list up to date so all questions asked on Github that have any merit will be added to this list.</p>\n<ul class="submenu">\n  <li><a href="#which-versions-of-node-are-supported-">Which versions of node are supported?</a></li>\n  <li><a href="#does-a-single-road-not-create-overhead-in-other-environments-">Does a single road not create overhead in other environments?</a></li>\n  <li><a href="#what-is-the-best-directory-structure-for-my-project-">What is the best directory structure for my project?</a></li>\n  <li><a href="#why-is-there-a-different-middleware-argument-signature-">Why is there a different middleware argument signature?</a></li>\n  <li><a href="#do-i-have-to-call-next-in-the-done-middleware-">Do I have to call next in the done middleware?</a></li>\n  <li><a href="#i-want-to-keep-the-relay-object-populated-after-a-request-how-do-i-do-that-">I want to keep the relay object populated after a request, how do I do that?</a></li>\n  <li><a href="#does-the-order-of-how-i-attch-middleware-to-the-road-matter-">Does the order of how I attch middleware to the road matter?</a></li>\n  <li><a href="#who-created-lagoon-road-">Who created Lagoon road?</a></li>\n  <li><a href="#where-does-the-name-come-from-">Where does the name come from?</a></li>\n</ul>\n\n<h3 id="which-versions-of-node-are-supported-">Which versions of node are supported?</h3>\n<p>The packages have hardly any dependencies and are very much just plain javascript, so everything from node 4.x up I expect to work. The code is written with ES6 so you might need to compile your code first with Babel to get it to run. Best practice is to use the newest version of node, for the simple reason that I haven&#39;t tested older versions. I developed with node 7.6.x</p>\n<h3 id="does-a-single-road-not-create-overhead-in-other-environments-">Does a single road not create overhead in other environments?</h3>\n<p>Yes, combining the middleware in a single place, will create overhead. But compared to what you gain from having everything connected in a single place, it is negligible. You will only create some extra properties on the internal objects within the core. Whenever the update event is fired the matches are done based on object key matches, so there is no extra filtering needed. Performance wise not really an issue.</p>\n<h3 id="what-is-the-best-directory-structure-for-my-project-">What is the best directory structure for my project?</h3>\n<p>Lagoon road doesn&#39;t force any structure on you. That is the phylosophy of Lagoon road, that you don&#39;t have to tie yourself down to any methodologies or structures. You want to work more in a component based manner, you can do so. Want to seperate your scripts from your styles, because you reuse your css over multiple components, also possible. This is the structure that I&#39;ve used for this website:</p>\n<pre><code>- source\n| <span class="hljs-type">- bootstrap</span>\n  | <span class="hljs-type">- client</span>.js\n  | <span class="hljs-type">- server</span>.js\n  | <span class="hljs-type">- road</span>.js\n| <span class="hljs-type">- extensions</span>\n  | <span class="hljs-type">- settings</span>\n    | <span class="hljs-type">- webserver</span>.js\n| <span class="hljs-type">- middleware</span>\n  | <span class="hljs-type">- components</span>\n    | <span class="hljs-type">- .. every</span> component <span class="hljs-built_in">in</span> a single file\n  | <span class="hljs-type">- layouts</span>\n    | <span class="hljs-type">.. every</span> layout <span class="hljs-built_in">in</span> a single file\n  | <span class="hljs-type">- events</span>\n    | <span class="hljs-type">- .. client</span> side dom code, every component <span class="hljs-built_in">in</span> a single file\n  | <span class="hljs-type">- response</span>\n    | <span class="hljs-type">- response</span>.js (html response <span class="hljs-keyword">for</span> the webserver)\n| <span class="hljs-type">- stylesheets</span>\n  | <span class="hljs-type">- components</span>\n    | <span class="hljs-type">.. every</span> component <span class="hljs-built_in">in</span> a single file\n  | <span class="hljs-type">- layouts</span>\n    | <span class="hljs-type">.. every</span> layout <span class="hljs-built_in">in</span> a single file\n  | <span class="hljs-type">- .. some</span> more general styles, like animation and typography\n  | <span class="hljs-type">- styles</span>.css (importing all other styles)\n</code></pre><p>Then all client side code will be pass through babel and browserify and the minifier. View the <a href="https://github.com/lagoon-road/lr-website/blob/master/package.json">package.json</a> and the [lr-website code]<a href="https://github.com/lagoon-road/lr-website">https://github.com/lagoon-road/lr-website</a></p>\n<h3 id="why-is-there-a-different-middleware-argument-signature-">Why is there a different middleware argument signature?</h3>\n<p>The reason that Lagoon road doesn&#39;t follow the standard argument order of, <code>request</code>, <code>response</code>, <code>next</code> and an optional <code>error</code> is because we are not only handling http requests and responses. In frameworks like Expressjs everything is centered around the the http protocol. In that setup it makes sense to have <code>request</code> and <code>response</code> come first. In Lagoon road we don&#39;t tie in http as the only protocol so the parameters for your middleware might be different. Same goes for the client. If we would have kept the order the same there will be a lot of cases where you are specifying parameters that are not really used. If you have traditional middleware that you want to plug in, you can make it run in the traditional order. See the <a href="/reference/middleware">reference about middleware</a> for more information.</p>\n<h3 id="do-i-have-to-call-next-in-the-done-middleware-">Do I have to call next in the done middleware?</h3>\n<p>It depends. If the done method is the last method in the stack, then you don&#39;t have to call the next function. But if you add multiple done hooks, which is a valid setup, you might need to add it because otherwise the next middleware in the stack will not be called. You can always call next, even if it is the last, it will just call an empty function.</p>\n<h3 id="i-want-to-keep-the-relay-object-populated-after-a-request-how-do-i-do-that-">I want to keep the relay object populated after a request, how do I do that?</h3>\n<p>This is pretty straight forward. You can just set the <code>resetAfterCycle</code> option on the core initialization. Check the <a href="/reference/lr-core">reference</a> for more information.</p>\n<h3 id="does-the-order-of-how-i-attch-middleware-to-the-road-matter-">Does the order of how I attch middleware to the road matter?</h3>\n<p>Yes it does. The first middleware that you add, will be put first in the stack. This is why Lagoon road is simple to reason about. You just start looking from the top and see what you first match is. That will be the first middleware that will be called. Read more about the <a href="/guide/stack-and-middleware">stack and middleware</a> in the guide.</p>\n<h3 id="who-created-lagoon-road-">Who created Lagoon road?</h3>\n<p><a href="http://royniels.nl">Me</a></p>\n<h3 id="where-does-the-name-come-from-">Where does the name come from?</h3>\n<p>The name comes from one of my favorite books, <em><a href="https://www.amazon.com/Surviving-Paradise-Year-Disappearing-Island/dp/B0044KN3CO&quot;">Surviving Paradise: One Year on a Disappearing Island</a></em>. At some point the protagonist is back on Majuro, an island in the Marshall Islands group and talks about the single road on the island.</p>\n<blockquote>\n<p>Taxis were a snap—stand on the appropriate side of the street, ﬂag down one of the six cabs that arrived every minute, and then sit in the cool dryness of the air-conditioning and enjoy the ride. No need to tell the driver your destination: since there was only one real road, you could simply tell him when to stop.</p>\n</blockquote>\n<p>The road that he is talking about is called Lagoon road, and since I am residing on Bali, a link with islands and the single road concept seemed like a good metaphore for the single object structure of Lagoon road.</p>\n\n    ',"article");
next()}},{}],9:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n        <h1 id="adding-server-side-renderer">Adding server side renderer</h1>\n<p>After creating a simple hello world example it is time to add some proper rendering to the server side. The following code uses the <code>lr-server-renderer</code> the let us easily add a template and components.</p>\n<h5 id="adding-server-side-renderer-source-bootstrap-webserver-js">adding-server-side-renderer/source/bootstrap/webserver.js</h5>\n<pre><code><span class="hljs-keyword">const</span> protocol = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'http\'</span>);\n<span class="hljs-keyword">const</span> server   = protocol.createServer();\n<span class="hljs-keyword">const</span> core     = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-core\'</span>);\n<span class="hljs-keyword">const</span> router   = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-server-router\'</span>)(server);\n<span class="hljs-keyword">const</span> renderer = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-server-renderer\'</span>)();\n<span class="hljs-keyword">const</span> debug    = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../extensions/debug\'</span>);\n\ncore(<span class="hljs-string">\'webserver\'</span>)\n  .extension(<span class="hljs-string">\'router\'</span>, router, <span class="hljs-literal">true</span>)\n  .extension(<span class="hljs-string">\'renderer\'</span>, renderer)\n  .extension(<span class="hljs-string">\'debug\'</span>, debug)\n  .middleware({\n    <span class="hljs-attr">debug</span>                   : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/debug\'</span>),\n    <span class="hljs-attr">response</span>                : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/response\'</span>),\n    <span class="hljs-string">\'components.home\'</span>       : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/components/home\'</span>),\n    <span class="hljs-string">\'components.navigation\'</span> : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/components/navigation\'</span>),\n    <span class="hljs-string">\'components.contact\'</span>    : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/components/contact\'</span>),\n    <span class="hljs-string">\'layouts.default\'</span>       : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/layouts/default\'</span>),\n  })\n  .run(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'debug\'</span>)\n  .run(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'layouts.default\'</span>)\n  .run(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'components.navigation\'</span>)\n  .run(<span class="hljs-string">\'/\'</span>, <span class="hljs-string">\'components.home\'</span>)\n  .run(<span class="hljs-string">\'/contact\'</span>, <span class="hljs-string">\'components.contact\'</span>)\n  .done(<span class="hljs-string">\'response\'</span>);\n\nserver.listen(<span class="hljs-number">8080</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'server running on localhost:8080\'</span>);\n});\n</code></pre><p>As you can see we added two more extensions. The <code>renderer</code> extension and the <code>debug</code> extension. The <code>renderer</code> extension is a package by itself so we will not go into specifics over how it is implemented, but we will look at the debug extension so you have a feel how you can write a simple extension.</p>\n<blockquote>\n<p>You can find the source code for the renderer extension on <a href="https://github.com/lagoon-road/lr-server-renderer/blob/master/index.js">github</a>.</p>\n</blockquote>\n<h5 id="adding-server-side-renderer-source-extensions-debug-js">adding-server-side-renderer/source/extensions/debug.js</h5>\n<pre><code><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> {\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'DEBUG: \'</span> + message);\n}\n</code></pre><p>As you can see the <code>debug</code> extension is nothing more then a function. In our case just a function around the <code>console.log</code>. This might not be the most useful extension but it shows how you can use extensions to centralize your code. If we were to use an actual logger/debugger like <code>debug</code>, <code>morgan</code> or <code>winston</code> we can create a very thin function wrapper and use the extension in all our middleware. When you change your debugger later, you only change the extension and have all the middleware automatically use it. Pretty DRY.</p>\n<p>So how would you use the extension in your middleware? Well for that we look at the <code>debug</code> middleware.</p>\n<pre><code>module.exports = (next, relay, request) =&gt; {\n  relay.extensions.debug(<span class="hljs-symbol">`</span>Incoming request [<span class="hljs-symbol">$</span><span class="hljs-symbol">{</span> request.method <span class="hljs-symbol">}</span>]: <span class="hljs-symbol">$</span><span class="hljs-symbol">{</span> request.url <span class="hljs-symbol">}</span><span class="hljs-symbol">`</span>);\n  next();\n}\n</code></pre><p>You can see how we can access the extension by using the <code>relay</code> object.</p>\n<h3 id="relay-object">Relay object</h3>\n<p>The relay object is something that you not see in standard middleware, but the concept is pretty simple. The <code>relay</code> object is passed from middleware to middleware, hence the name relay. Every extension, or variable that you add becomes available in every middleware function that comes after it. All <code>extensions</code> are available at <code>relay.extensions.extensionName</code>.</p>\n<p>When you want to set a variable in your middleware that needs to be available to all the following middleware you simply pass and object to the <code>next</code> function like so:</p>\n<pre><code><span class="hljs-selector-tag">next</span>({ <span class="hljs-attribute">someVariable </span>: true });\n</code></pre><p>The object will automatically be merged with existing <code>relay</code> variables which makes it easy to pass on data between middleware.</p>\n<blockquote>\n<p>If you want to use the relay object as a state manager it might be handy to add all the state to a state object.</p>\n<pre><code>module.exports = (next, relay) =&gt; {\n  const <span class="hljs-keyword">state</span> = Object.assign({}, relay.<span class="hljs-keyword">state</span>, { someNewProperty : true});\n  next({ <span class="hljs-keyword">state</span> });\n}\n</code></pre><p>This way it is easy to send everything from the server to the client in the template, which saves you to make redundant calls from the client.</p>\n</blockquote>\n<h3 id="listening-for-changes">Listening for changes</h3>\n<p>Now that we added some middleware for our debugger it is time to let it listen for http requests.</p>\n<pre><code>.<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'debug\'</span>)\n</code></pre><p>As you can see we use a new method, namely <code>run</code>. The <code>run</code> method can be thought of as the <code>get</code> method in traditional middleware. Whenever a <code>GET</code> request comes in it will be triggered. The reason for not calling it get is that we are not limited to only use the http protocol. So it would make little sense to call it get. Furthermore you can see that you can use the asterix (*) symbol to listen to all <code>GET</code> requests.</p>\n<blockquote>\n<p>If you need to listen to another method, or in Lagoon road called <code>updateType</code>. You can specify a third parameter.</p>\n<pre><code>.<span class="hljs-built_in">run</span>(*, <span class="hljs-string">\'debug\'</span>, <span class="hljs-string">\'post\'</span>)\n</code></pre></blockquote>\n<h3 id="adding-a-template">Adding a template</h3>\n<p>Great so we have added a simple debug function, time to get our templating up and running. First we want to define a template.</p>\n<pre><code>module.exports = (next, relay) =&gt; {\n  relay.extensions.debug(\'selecting template\');\n  relay.extensions.renderer.template(`\n    <span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Adding client side routing<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">""</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"author"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"Roy Niels"</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"content"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n  `);\n  next();\n}\n</code></pre><p>We are using the <code>renderer</code> extension to set the template. The <code>template</code> method needs a single argument, which is a string with raw html. It has a <code>&lt;nav&gt;</code> and <code>&lt;section class=&quot;content&quot;&gt;&lt;/section&gt;</code> tag. This is were our components will be placed.</p>\n<p>Each request needs a template so we add it like we did with the <code>debug</code> middleware, with an asterix.</p>\n<pre><code>.<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'layouts.default\'</span>)\n</code></pre><p>You can see that you can easily use multiple templates for different routes if you wish to.</p>\n<blockquote>\n<p>We are passing in raw html to the renderer. Because of this it becomes very easy to use any templating engine, as long as you get a string back, you can use whatever you want. This is one of the ways that Lagoon road is unopinionated.</p>\n</blockquote>\n<h3 id="adding-a-component">Adding a component</h3>\n<p>The template is in place, time to add the components. We will look at the middleware for the contact page, all the other components use the same technique.</p>\n<pre><code><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">next</span>, relay)</span> =&gt;</span> {\n  relay.extensions.<span class="hljs-built_in">debug</span>(<span class="hljs-string">\'rendering contact\'</span>);\n  relay.extensions.renderer.render(<span class="hljs-string">\'&lt;h1&gt;This is the contact page&lt;/h1&gt;\'</span>, <span class="hljs-string">\'.content\'</span>);\n  <span class="hljs-built_in">next</span>();\n}\n</code></pre><p>We use the same renderer extension as we used for the template, but a different method, <code>render</code>. This  method takes two parameters. The first one, again a raw html string, the second one, a html selector. Just like you do when working with the regular browser DOM.</p>\n<p>Hooking it up to the road is slightly different, we want to only render the component on the <code>/contact</code> page, so we will set up the <code>matchValue</code> accordingly</p>\n<pre><code>.<span class="hljs-built_in">run</span>(<span class="hljs-string">\'/contact\'</span>, <span class="hljs-string">\'component.contact\'</span>)\n</code></pre><blockquote>\n<p><code>matchValue</code> is the first argument in the <code>run</code> method.</p>\n</blockquote>\n<h3 id="rendering-the-output">Rendering the output</h3>\n<p>We have slightly changed the response middleware to accommodate the <code>renderer</code> extension.</p>\n<pre><code><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">next</span>, relay, request, response)</span> =&gt;</span> {\n  relay.extensions.<span class="hljs-built_in">debug</span>(<span class="hljs-string">\'sending html response\'</span>);\n  response.end(relay.extensions.renderer.html());\n}\n</code></pre><p>We call the <code>html</code> method to get a fully renderer html page as a string and send that back to the client.</p>\n<p>Before we go and add the client side code to create a single page app, we want to take a look at how we can handle static content, like our javascript files, images and stylesheets.</p>\n<p>Next: <a href="/guide/handling-static-content">Handling static content</a></p>\n\n    ',"article");next()}},{}],10:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n        <h1 id="handling-static-content">Handling static content</h1>\n<p><strong>Although it is possible to add middleware to handle your static files, like scripts, images and stylesheets. It is better to do this via a reverse proxy on a webserver like Nginx. Node is not the best choice when it comes to serving static content. This is way easier with a Nginx setup. It is trivial to gzip your files, add caching and catch redundant calls to your node server.\nFurthermore it is pretty straight forward to add HTTPS with let&#39;s encrypt.</strong></p>\n<p><strong>Read more about reverse proxies and Nginx in <a href="https://code.lengstorf.com/deploy-nodejs-ssl-digitalocean/">this</a> outstanding post. Although it is for a Digital Ocean droplet, it shows you very clearly how to setup a reverse proxy that you can use without Digital Ocean.</strong></p>\n<p>For testing purposes you might want to use some static middleware. The following code is mainly a copy from <a href="https://developer.mozilla.org/en-US/docs/Node_server_without_framework">here</a> with some small adjustments to accommodate Lagoon road.</p>\n<pre><code>const url  = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'url\'</span>);\nconst fs   = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'fs\'</span>);\nconst path = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'path\'</span>);\n\n<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">next</span>, relay, request, response)</span> =&gt;</span> {\n  const parsedUrl = url.parse(request.url);\n  let pathname    = `.${ parsedUrl.pathname }`;\n  const extension = path.parse(pathname).ext;\n\n  const fileTypes = {\n    <span class="hljs-string">\'.ico\'</span>  : <span class="hljs-string">\'image/x-icon\'</span>,\n    <span class="hljs-string">\'.html\'</span> : <span class="hljs-string">\'text/html\'</span>,\n    <span class="hljs-string">\'.js\'</span>   : <span class="hljs-string">\'text/javascript\'</span>,\n    <span class="hljs-string">\'.json\'</span> : <span class="hljs-string">\'application/json\'</span>,\n    <span class="hljs-string">\'.css\'</span>  : <span class="hljs-string">\'text/css\'</span>,\n    <span class="hljs-string">\'.png\'</span>  : <span class="hljs-string">\'image/png\'</span>,\n    <span class="hljs-string">\'.jpg\'</span>  : <span class="hljs-string">\'image/jpeg\'</span>,\n    <span class="hljs-string">\'.wav\'</span>  : <span class="hljs-string">\'audio/wav\'</span>,\n    <span class="hljs-string">\'.mp3\'</span>  : <span class="hljs-string">\'audio/mpeg\'</span>,\n    <span class="hljs-string">\'.svg\'</span>  : <span class="hljs-string">\'image/svg+xml\'</span>,\n    <span class="hljs-string">\'.pdf\'</span>  : <span class="hljs-string">\'application/pdf\'</span>,\n    <span class="hljs-string">\'.doc\'</span>  : <span class="hljs-string">\'application/msword\'</span>\n  };\n\n  // Not static\n  <span class="hljs-keyword">if</span> (!fileTypes[extension]) {\n    relay.extensions.<span class="hljs-built_in">debug</span>(`${ request.url } is <span class="hljs-keyword">not</span> static`);\n    <span class="hljs-built_in">next</span>();\n    <span class="hljs-keyword">return</span>;\n  }\n\n  fs.exists(pathname, <span class="hljs-function"><span class="hljs-params">(exist)</span> =&gt;</span> {\n    <span class="hljs-keyword">if</span>(!exist) {\n      relay.extensions.<span class="hljs-built_in">debug</span>(`${ pathname } does <span class="hljs-keyword">not</span> exist on disk`);\n      response.end(<span class="hljs-string">\'404 - File not found\'</span>);\n      relay.exit();\n    } <span class="hljs-keyword">else</span> {\n      relay.extensions.<span class="hljs-built_in">debug</span>(`${ pathname } does exist loading it`);\n      // read file <span class="hljs-keyword">from</span> file system\n      fs.readFile(pathname, <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">error</span>, data)</span> =&gt;</span> {\n        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">error</span>){\n          relay.extensions.<span class="hljs-built_in">debug</span>(`File ${ pathname } <span class="hljs-keyword">not</span> found on disk`);\n          response.end(<span class="hljs-string">\'404 - File not found\'</span>);\n        } <span class="hljs-keyword">else</span> {\n          relay.extensions.<span class="hljs-built_in">debug</span>(<span class="hljs-string">\'sending back static file: \'</span> + pathname);\n          response.setHeader(<span class="hljs-string">\'Content-type\'</span>, fileTypes[extension] || <span class="hljs-string">\'text/plain\'</span> );\n          response.end(data);\n        }\n        relay.exit();\n      });\n    }\n  });\n}\n</code></pre><p>We will not going to much into detail on how this middleware works, it is pretty self explanatory. The only thing to notice is that we use <code>relay.exit()</code> after we are done responding to a static request. Read the <a href="/guide/stack-and-middleware">stack and middleware</a> section to find out why.</p>\n<p>Next: <a href="/guide/make-a-single-page-app">Turn your server side rendered page in to a single page app</a></p>\n\n    ',"article");next()}},{}],11:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n        <h1 id="hello-world">Hello world</h1>\n<p>The most simple and of course mandatory example is the hello-world example. In our case it will be a server only response which you can check in your browser. To make it happen open a browser tab and navigate to <code>http://localhost:8080</code>. This should show you a nice header with <em>Hello World</em>.</p>\n<blockquote>\n<p>Check the <a href="/guide/setup">setup and running the examples</a> to see how to start the webserver.</p>\n</blockquote>\n<h4 id="the-code">The code</h4>\n<p>Let&#39;s have a look at how the response has been generated.</p>\n<h5 id="hello-world-source-bootstrap-webserver-js">hello-world/source/bootstrap/webserver.js</h5>\n<pre><code><span class="hljs-keyword">const</span> protocol = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'http\'</span>);\n<span class="hljs-keyword">const</span> server   = protocol.createServer();\n<span class="hljs-keyword">const</span> core     = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-core\'</span>);\n<span class="hljs-keyword">const</span> router   = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-server-router\'</span>)(server);\n\ncore(<span class="hljs-string">\'webserver\'</span>)\n  .extension(<span class="hljs-string">\'router\'</span>, router, <span class="hljs-literal">true</span>)\n  .middleware({\n    <span class="hljs-attr">response</span> : <span class="hljs-function">(<span class="hljs-params">next, relay, request, response</span>) =&gt;</span> {\n      response.end(<span class="hljs-string">\'&lt;h1&gt;Hello world&lt;/h1&gt;\'</span>);\n    }\n  })\n  .done(<span class="hljs-string">\'response\'</span>);\n\nserver.listen(<span class="hljs-number">8080</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'server running on localhost:8080\'</span>);\n});\n</code></pre><p>As you can see, it is a pretty straight forward process to get the response back from the server. First we add some standard packages and create the node server.</p>\n<p>The first thing that needs some explanation is the router package.</p>\n<pre><code>const router   = require(\'lr-server-router\')(<span class="hljs-name">server</span>)<span class="hljs-comment">;</span>\n</code></pre><p>The router package is a simple wrapper around the server request event and takes care of routing the request throught the core. As you can see it needs one argument, namely the server that you want to use.</p>\n<blockquote>\n<p>Lagoon road doesn&#39;t limit itself to the HTTP protocol. Using websockets, or maybe both together, <a href="guide/extensions">extensions</a> are the way to go.</p>\n</blockquote>\n<p>The next step is initializing the core and create a road object.</p>\n<pre><code><span class="hljs-function"><span class="hljs-title">core</span><span class="hljs-params">(<span class="hljs-string">\'webserver\'</span>)</span></span>\n</code></pre><p>We intialize the core here with a single argument. The argument is the identifier for our environment. Each time you initialize the road you want to tell it the context of where we want to attach the middleware and extensions. In this case we want to run it as a web server so we use that as the identifier.</p>\n<blockquote>\n<p>The executing environment, in this case <code>webserver</code> will make more sense when we have more environments and start sharing code between them. We will look at that in the next examples.</p>\n</blockquote>\n<p>After we have initialized the road we want to attach our router as an extension.</p>\n<pre><code>.extension(<span class="hljs-string">\'router\'</span>, router, <span class="hljs-literal">true</span>)\n</code></pre><p>It is very simple to add an extension. Just give it an id, the first argument, add the package, the second argument, and you are done. In our case we have a third argument, a boolean. This tells the core to execute the middleware on initialization. This is typically for packages that can trigger updates, like a router, that receives request events.</p>\n<blockquote>\n<p>To learn more about extensions and execution on initialization read about writing <a href="/guide/extensions">extensions</a></p>\n</blockquote>\n<p>Now that we added the router as an extension, we can actually receive request events. In order to act upon these events we need to add some middleware.</p>\n<pre><code><span class="hljs-selector-class">.middleware</span>({\n  <span class="hljs-attribute">response </span>: (next, relay, request, response) =&gt; {\n    response.<span class="hljs-built_in">end</span>(<span class="hljs-string">\'&lt;h1&gt;Hello world&lt;/h1&gt;\'</span>);\n  }\n})\n</code></pre><p>As you can see the middleware method expects an object as argument. It is a flat, non nested object where you can assign all the middleware that you need. In our case that is a single one. The middleware might have an odd argument signature for people who are familiar with middleware. There is a good reason for this change which you can read about in the <a href="/faq#middlware-signature">faq</a> section. The middlware is a simple response that sends back the html that we want to show on the client. Last step in the process, add the middleware to a event.</p>\n<pre><code><span class="hljs-selector-class">.done</span>(<span class="hljs-string">\'response\'</span>)\n</code></pre><p>To act upon an event that might be triggered by the router, we need to add some listeners to the road. There are a couple of ways to do this. There is <code>run</code>, <code>noMatch</code>, <code>error</code> and <code>done</code>. The first three we will see in the following examples in this guide. For now we use the <code>done</code> hook. The <code>done</code> hook is the last middleware hook that gets added to the stack of middleware that needs to be executed. It is the perfect place to respond to requests and as we will see later, render html. As you can see, the method takes a single argument, the middleware id. The middleware id is the key in the object that we specified in the middelware method. Now we have added a listener to the road, so whenever an update happends, regardless of the path it will go through the <code>done</code> method and in our case respond with a nice &#39;hello world&#39;.</p>\n<blockquote>\n<p>Read more about how the updates and middleware stack work in the <a href="/guide/stack-and-middleware">stack and middleware</a> guide.</p>\n</blockquote>\n<p>Now that we have got our feet wet in the warm calm waters of Lagoon road it is time to add a server side renderer to send some proper html back.</p>\n<p>Next: <a href="/guide/adding-server-side-renderer">Adding the server side renderer</a></p>\n\n    ',"article");next()}},{}],12:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n    <h1>Guide</h1>\n    <p>Select on of the following guides</p>\n    <ul class="submenu">\n      <li><a href="/guide/setup">Setup and running the examples</a></li>\n      <li><a href="/guide/hello-world">Hello world</a></li>\n      <li><a href="/guide/adding-server-side-renderer">Adding the server side renderer</a></li>\n      <li><a href="/guide/make-a-single-page-app">Turn your server side rendered page into a single page app</a></li>\n      <li><a href="/guide/working-with-dom-events">Working with DOM events</a></li>\n      <li><a href="/guide/adding-url-parameters-via-a-parser">Adding url parameters via a parser</a></li>\n      <li><a href="/guide/rendering-content-via-renderers">Rendering content via renderers</a></li>\n      <li><a href="/guide/stack-and-middleware">Stack and middleware, in-depth</a></li>\n      <li><a href="/guide/writing-middleware">Writing middleware</a></li>\n      <li><a href="/guide/writing-extenions">Writing extensions</a></li>\n      <li><a href="/guide/writing-parsers">Writing parsers</a></li>\n    </ul>\n  ',"article");next()}},{}],13:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n        <h1 id="make-a-single-page-app">Make a single page app</h1>\n<p>Now that we have all the server side stuff in place it is time to spice things up a bit and show you where Lagoon road really shines, sharing code between environments. Let&#39;s first show you the code that we use to make it all work.</p>\n<h5 id="lr-examples-make-a-single-page-app-source-webserver-js">lr-examples/make-a-single-page-app/source/webserver.js</h5>\n<pre><code><span class="hljs-keyword">const</span> protocol = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'http\'</span>);\n<span class="hljs-keyword">const</span> server   = protocol.createServer();\n<span class="hljs-keyword">const</span> router   = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-server-router\'</span>)(server);\n<span class="hljs-keyword">const</span> renderer = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-server-renderer\'</span>)();\n<span class="hljs-keyword">const</span> road     = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-core\'</span>)(<span class="hljs-string">\'webserver\'</span>)\n  .extension(<span class="hljs-string">\'router\'</span>, router, <span class="hljs-literal">true</span>)\n  .extension(<span class="hljs-string">\'renderer\'</span>, renderer)\n  .middleware({\n    <span class="hljs-string">\'layouts.default\'</span> : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/layouts/default\'</span>),\n    <span class="hljs-attr">response</span>          : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/response\'</span>),\n    <span class="hljs-attr">statics</span>           : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/statics\'</span>),\n  });\n\n<span class="hljs-built_in">require</span>(<span class="hljs-string">\'./road\'</span>)(road);\n\nserver.listen(<span class="hljs-number">8080</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'server running on localhost:8080\'</span>);\n});\n</code></pre><p>The webserver in basically the same as in the server side example, except that we removed the middleware that we want to share between enviroments. Only the middleware that is exclusive for the webserver is added in this file.</p>\n<p>After we have setup the road, we pass it down to a new file, <code>require(&#39;./road&#39;)</code>.</p>\n<pre><code><span class="hljs-selector-tag">require</span>(<span class="hljs-string">\'./road\'</span>)(road);\n</code></pre><p>This is the file that we will use for all the shared code between environments.</p>\n<h5 id="lr-examples-make-a-single-page-app-source-client-js">lr-examples/make-a-single-page-app/source/client.js</h5>\n<pre><code><span class="hljs-keyword">const</span> router   = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-client-router\'</span>);\n<span class="hljs-keyword">const</span> renderer = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-client-renderer\'</span>);\n<span class="hljs-keyword">const</span> road     = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-core\'</span>)(<span class="hljs-string">\'client\'</span>)\n  .extension(<span class="hljs-string">\'router\'</span>, router, <span class="hljs-literal">true</span>)\n  .extension(<span class="hljs-string">\'renderer\'</span>, renderer, <span class="hljs-literal">true</span>)\n  .middleware({\n    <span class="hljs-string">\'response\'</span> : <span class="hljs-function">(<span class="hljs-params">next, relay</span>) =&gt;</span> { relay.extensions.renderer.html() }\n  });\n\n<span class="hljs-built_in">require</span>(<span class="hljs-string">\'./road\'</span>)(road);\n</code></pre><p>As you can see the client side code looks very similar to the web server code, the packages are different but are hooked in under the exact same name, this allows us to use the same middleware for both client and server. Specific client side middleware is hooked up in the <code>client.js</code> file.</p>\n<h5 id="lr-examples-make-a-single-page-app-source-road-js">lr-examples/make-a-single-page-app/source/road.js</h5>\n<pre><code><span class="hljs-keyword">const</span> debug = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../extensions/debug\'</span>);\n\n<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">road</span> =&gt;</span> {\n  road\n    .extension(<span class="hljs-string">\'debug\'</span>, debug)\n    .middleware({\n      <span class="hljs-attr">debug</span>                   : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/debug\'</span>),\n      <span class="hljs-string">\'components.navigation\'</span> : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/components/navigation\'</span>),\n      <span class="hljs-string">\'components.home\'</span>       : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/components/home\'</span>),\n      <span class="hljs-string">\'components.contact\'</span>    : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../middleware/components/contact\'</span>)\n    })\n    .where(<span class="hljs-string">\'webserver\'</span>)\n      .run(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'debug\'</span>)\n      .run(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'statics\'</span>)\n      .run(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'layouts.default\'</span>)\n    .where(<span class="hljs-string">\'webserver\'</span>, <span class="hljs-string">\'client\'</span>)\n      .run(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'components.navigation\'</span>)\n      .run(<span class="hljs-string">\'/\'</span>, <span class="hljs-string">\'components.home\'</span>)\n      .run(<span class="hljs-string">\'/contact\'</span>, <span class="hljs-string">\'components.contact\'</span>)\n      .done(<span class="hljs-string">\'response\'</span>);\n}\n</code></pre><p>Lastly the file where all the magic happends, <code>road.js</code>. As you might have expected is this file more or less the same as the other two files, middleware is hooked up, extensions added and listeners (<code>run</code> and <code>done</code>) listening. The road file is the place where we add all the stuff that needs to be shared between our environments. This is not limited to the client and web server. If you have an api server you can add the listeners here too. You have a single file were you can find all the paths that your app is using. It becomes very easy to figure out the flow of your app.</p>\n<p>You can see that we use a new method</p>\n<pre><code>.<span class="hljs-keyword">where</span>(<span class="hljs-string">\'webserver\'</span>)\n</code></pre><p>This method sets the context for all the following methods, so the core knows that the <code>run</code> method belongs to the webserver. Sharing methods between environments becomes a breeze, just add all the environments that need to share code and you are done.</p>\n<pre><code>.<span class="hljs-keyword">where</span>(<span class="hljs-string">\'webserver\'</span>, <span class="hljs-string">\'client\'</span>)\n</code></pre><p>Next: <a href="/guide/working-with-dom-events">Working with DOM events</a></p>\n\n    ',"article");
next()}},{}],14:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n        <h1 id="installing-lagoon-road">Installing Lagoon Road</h1>\n<p>Like any other npm package you can just run</p>\n<pre><code>npm <span class="hljs-selector-tag">i</span> --save lr-core\n</code></pre><p>All the package names for the supplied packages can be found in the <a href="/reference">reference overview</a>.</p>\n<h2 id="following-the-examples">Following the examples</h2>\n<p>The easiest way to follow the examples is just to clone the lr-examples repo. This repo contains some build tools that help generating client side js code. So you don&#39;t have to manually setup Babel, Browserify and the likes.</p>\n<p>If you feel more adventurous, you can just checkout the packages you need and glance over the examples, it will show you how to use the road on client and server among some other common scenarios.</p>\n<p>To clone the repo just go to your preferred directory and run one of the two following commands:</p>\n<p><strong>SSH</strong>  </p>\n<pre><code>git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:lagoon-road/lr-examples.git\n</code></pre><p><strong>HTTPS</strong>  </p>\n<pre><code>git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/lagoon-road/lr-examples.git\n</code></pre><p>In the repo you can find folders for all the examples. Most folders will contain a <code>source</code> folder and a <code>public</code> folder. The <code>source</code> folder is where we write our code and it is also the folder which the node server will use to serve its responses.</p>\n<p>The <code>public</code> folder is the folder where the generated client side code will be saved. There are some <code>scripts</code> in the <code>package.json</code> file that help you do that.</p>\n<pre><code>npm <span class="hljs-keyword">run</span><span class="bash"> watch</span>\n</code></pre><p>This command will build the client side code and watches file changes.</p>\n<p>To start the server you can simply run</p>\n<pre><code>npm <span class="hljs-keyword">run</span><span class="bash"> serve</span>\n</code></pre><p>Before you can run the code, you need to install all the npm packages, to do so run the command below, you only have to do this once.</p>\n<pre><code>npm <span class="hljs-keyword">install</span>\n</code></pre><h4 id="next-hello-world-guide-hello-world-">Next: <a href="/guide/hello-world">Hello-world</a></h4>\n\n    ',"article");next()}},{}],15:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n        <h1 id="working-with-dom-events">Working with DOM events</h1>\n<p>In this guide we will do a simple <code>console.log</code> from our event middleware that will show you that the DOM is ready to be accessed.</p>\n<h5 id="working-with-dom-events-source-events-navigation-js">working-with-dom-events/source/events/navigation.js</h5>\n<pre><code><span class="hljs-built_in">module</span>.exports = (next, relay) =&gt; {\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`There</span> are <span class="hljs-string">${</span> <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">\'nav\').children.length</span> <span class="hljs-string">}</span> menu items<span class="hljs-string">`);</span>\n  next();\n}\n</code></pre><p>Just a regular middleware function that should give is the number of menu items.</p>\n<h5 id="working-with-dom-events-source-bootstrap-client-js">working-with-dom-events/source/bootstrap/client.js</h5>\n<pre><code><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">"DOMContentLoaded"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{\n  <span class="hljs-keyword">const</span> router   = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-client-router\'</span>);\n  <span class="hljs-keyword">const</span> renderer = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-client-renderer\'</span>);\n  <span class="hljs-keyword">const</span> core     = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'lr-core\'</span>);\n  <span class="hljs-keyword">const</span> road     = core(<span class="hljs-string">\'client\'</span>)\n    .extension(<span class="hljs-string">\'router\'</span>, router, <span class="hljs-literal">true</span>)\n    .extension(<span class="hljs-string">\'renderer\'</span>, renderer, <span class="hljs-literal">true</span>)\n    .middleware({\n      <span class="hljs-string">\'response\'</span>          : <span class="hljs-function">(<span class="hljs-params">next, relay</span>) =&gt;</span> { relay.extensions.renderer.html() },\n      <span class="hljs-string">\'events.navigation\'</span> : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../events/navigation\'</span>)\n    });\n\n  <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./road\'</span>)(road)\n    .where(<span class="hljs-string">\'client\'</span>)\n      .update({ <span class="hljs-attr">matchValue</span> : <span class="hljs-string">\'nav\'</span>, <span class="hljs-attr">updateType</span> : <span class="hljs-string">\'domReady\'</span> })\n});\n</code></pre><p>The most changes have happend in the <code>client.js</code> file. Firstly we wrapped the whole code in a <code>DOMContentLoaded</code> event handler. The reason for this is that we want to initialize the events middleware when we first open the page.</p>\n<p>You can see that we also added the <code>events.navigation</code> middleware to this file, DOM events happen only on the client so this will make sense.</p>\n<p>The third and last change is the following piece of code</p>\n<pre><code><span class="hljs-selector-tag">require</span>(<span class="hljs-string">\'./road\'</span>)(road)\n  <span class="hljs-selector-class">.where</span>(<span class="hljs-string">\'client\'</span>)\n    <span class="hljs-selector-class">.update</span>({ <span class="hljs-attribute">matchValue </span>: <span class="hljs-string">\'nav\'</span>, <span class="hljs-attribute">updateType </span>: <span class="hljs-string">\'domReady\'</span> })\n</code></pre><p>We have changed the <code>road.js</code> file so that it gives us back the <code>road</code> object. Once the shared methods have been applied to the road it is time to fire a manual <code>update</code> event. The <code>update</code> event takes a single object as argument with two parameters. The <code>matchValue</code> and <code>updateType</code>. In this case we want to update our road for all the <code>nav</code> html selectors that have an <code>updateType</code> of <code>domReady</code>. You can see here that Lagoon road is in no way limited to handle the http protocol. We are doing updates based on html selectors and give it a custom <code>updateType</code>!</p>\n<blockquote>\n<p>It is good practice to always wrap the <code>client.js</code> file in a <code>DOMContentLoaded</code> event. This way you can always update the road when you need to.</p>\n</blockquote>\n<h5 id="working-with-dom-events-source-bootstrap-road-js">working-with-dom-events/source/bootstrap/road.js</h5>\n<pre><code><span class="hljs-keyword">const</span> debug = require(<span class="hljs-string">\'../extensions/debug\'</span>);\n\n<span class="hljs-keyword">module</span>.exports = road =&gt; {\n  <span class="hljs-built_in">return</span> road\n    .extension(<span class="hljs-string">\'debug\'</span>, debug)\n    .middleware({\n      debug                   : require(<span class="hljs-string">\'../middleware/debug\'</span>),\n      <span class="hljs-string">\'components.navigation\'</span> : require(<span class="hljs-string">\'../middleware/components/navigation\'</span>),\n      <span class="hljs-string">\'components.home\'</span>       : require(<span class="hljs-string">\'../middleware/components/home\'</span>),\n      <span class="hljs-string">\'components.contact\'</span>    : require(<span class="hljs-string">\'../middleware/components/contact\'</span>)\n    })\n    .where(<span class="hljs-string">\'webserver\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'debug\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'statics\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'layouts.default\'</span>)\n    .where(<span class="hljs-string">\'client\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'nav\'</span>, <span class="hljs-string">\'events.navigation\'</span>, <span class="hljs-string">\'domReady\'</span>)\n    .where(<span class="hljs-string">\'webserver\'</span>, <span class="hljs-string">\'client\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'components.navigation\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'/\'</span>, <span class="hljs-string">\'components.home\'</span>)\n      .<span class="hljs-built_in">run</span>(<span class="hljs-string">\'/contact\'</span>, <span class="hljs-string">\'components.contact\'</span>)\n      .done(<span class="hljs-string">\'response\'</span>);\n}\n</code></pre><p>The last file that has changed is the <code>road.js</code> file. Two changes have been made to this file. We are returning the road object, so the client can initiate the update on <code>DOMContentLoaded</code>. The other change is the following code</p>\n<pre><code><span class="hljs-selector-class">.where</span>(<span class="hljs-string">\'client\'</span>)\n  <span class="hljs-selector-class">.run</span>(<span class="hljs-string">\'nav\'</span>, <span class="hljs-string">\'events.navigation\'</span>, <span class="hljs-string">\'domReady\'</span>)\n</code></pre><p>We have added a listener for the <code>nav</code> html selector with <code>updateType</code> <code>domReady</code>. Every time the navigation is re-rendered it will trigger the appropriate middleware.</p>\n<blockquote>\n<p>The <code>lr-client-renderer</code> is the package that sends out events whenever a component is ready and loaded in the dom.</p>\n</blockquote>\n\n    ',"article");next()}},{}],16:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n    <section class="home">\n      <div class="logo-text">\n        <h1>Lagoon road <span>Laid back webapps</span></h1>\n      </div>\n      <hr>\n      <p class="standout">Lagoon road helps you build webapps. It is not as low level as writing Javascript from scratch and it is not as high level as frameworks that can limit your flexibility. It sits right in the middle. It helps you to give structure to your app, lets you plug and play any package you like and doesn\'t get in the way to let you write code the way you like it. Lagoon road is laid back...</p>\n      <p>In Lagoon road, we turn everything in to middleware. Routing, templating, you name it. All this middleware is connected to a single object, which we call the <em>road</em>. You can picture it as a single road on an island. You can never get lost, it is either left or right. In Lagoon road it is even simpeler, it is a one way road.</p>\n      <p>Everything on the road is used by all environments that you are running, a web server, an API server, the client or even your Raspberry Pie/Aurdino and Mobile device. Because of this it becomes a breeze to share code among these environments and still keeping everything code wise DRY. Sharing routes between client and web server, have login checks for the api server and web server, sharing is how Lagoon road works best.</p>\n      <p>Lagoon road is not a monolithic framework that does everything out of the box. The core, and only mandatory package is less then 200 lines of code. You can add extensions (regular npm packages) to mold it in a system that works for you or your team. You remain in control over how to work and code.</p>\n      <section class="highlight">\n        <h2>Where from here?</h2>\n        <p>\n          <a href="/guide" class="pure-button">Examples in the <strong>guide</strong></a>\n          <a href="/reference" class="pure-button">Details in the <strong>reference</strong></a>\n          <a href="/faq" class="pure-button">Answers in the <strong>FAQ</strong></a>\n        </p>\n      </section>\n      <h2>Some <span class="laid-back">laid back</span> features of lagoon road</h2>\n      <ul class="features">\n        <li><span>1</span>It is modular, don\'t like a package, switch it for something else, it is all just npm packages, so plug and play the way you like</li>\n        <li><span>2</span>Websockets, HTTP(2), you can switch protocols without having to change the way you build your app</li>\n        <li><span>3</span>Plug in any store you like, you are not tied down to a single choice, you can even run multiple different ones next to each other</li>\n        <li><span>4</span>Share code between environments and keep it organized, even when you scale up</li>\n        <li><span>5</span>Want to hook up a Raspberry Pie or Arduino, sure thing, you can check for changes on sensory output and feed it straight into an api server, web server or straight to the browser</li>\n        <li><span>6</span>You know how middleware works? You are up and running for Lagoon road, no endless docs you have to plow through</li>\n      </ul>\n    </section>\n  ',"article");next()}},{}],17:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n    <nav>\n      <ul>\n        <li><a href="/">Home</a></li>\n        <li><a href="/guide">Guide</a></li>\n        <li><a href="/reference">Reference</a></li>\n        <li><a href="/faq">Faq</a></li>\n      </ul>\n    </nav>\n  ',"#navigation");next()}},{}],18:[function(require,module,exports){"use strict";module.exports=function(next,relay,request){relay.extensions.renderer.render("\n    <h1>404 - Page not found</h1>\n    <pre>\n      Oh my, "+request.url+" could not be found\n    </pre>\n  ","article");next()}},{}],19:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n    <h1>Reference</h1>\n    <p>Although Lagoon road needs only a single package to be up and running, namely lr-core, it comes with additional packages that make it easy to do some common tasks, like routing and rendering.</p>\n    <ul class="submenu">\n      <li><a href="/reference/lr-core">lr-core</a></li>\n      <li><a href="/reference/lr-server-router">lr-server-router</a></li>\n      <li><a href="/reference/lr-server-renderer">lr-server-renderer</a></li>\n      <li><a href="/reference/lr-client-router">lr-client-router</a></li>\n      <li><a href="/reference/lr-client-renderer">lr-client-renderer</a></li>\n      <li><a href="/reference/lr-url-parser">lr-url-parser</a></li>\n    </ul>\n  ',"article");next()}},{}],20:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n        <h1 id="lg-client-renderer-reference">lg-client-renderer reference</h1>\n<p>A Lagoon road extension that gives you renderer functionality on the client. This renderer does quick replacement and doesn&#39;t do virtual dom html difference changes. It should suffice for about 95% of all cases. When you start working more with a websocket pub/sub system you might want to consider writing your own renderer or use a virtual dom approach so user input will not get replaced on dom updates. Read more about writing extensions in the <a href="https://www.lagoonroad.com/guide">guide</a>.</p>\n<table>\n<thead>\n<tr>\n<th>Information</th>\n<th>-</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Code coverage</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Repo link</td>\n<td><a href="https://github.com/lagoon-road/lr-client-renderer">lr-client-renderer</a></td>\n</tr>\n<tr>\n<td>Dependencies</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Size (Browserify, Babel, Uglify and Gzip)</td>\n<td>789 bytes</td>\n</tr>\n<tr>\n<td>Version</td>\n<td>1.0.0</td>\n</tr>\n<tr>\n<td>License</td>\n<td>MIT</td>\n</tr>\n<tr>\n<td>Usage</td>\n<td><a href="https://www.lagoonroad.com/guide">lagoonroad.com/guide</a></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id="adding-the-extension-to-lagoon-road">Adding the extension to lagoon road</h3>\n<pre><code><span class="hljs-attribute">const router</span>   = require(<span class="hljs-string">\'lg-client-renderer\'</span>);\n<span class="hljs-attribute">const core</span>     = require(<span class="hljs-string">\'lr-core\'</span>);\n<span class="hljs-attribute">const road</span>     = core(<span class="hljs-string">\'client\'</span>)\n  .extension(<span class="hljs-string">\'renderer\'</span>, renderer, true);\n</code></pre><hr>\n<h3 id="renderer-render-html-placeholder-">renderer.render(html, placeholder)</h3>\n<pre><code><span class="hljs-keyword">renderer</span>.<span class="hljs-keyword">render</span>(<span class="hljs-string">\'&lt;section&gt;...&lt;/section&gt;\'</span>, <span class="hljs-string">\'.placeholderName\'</span>);\n</code></pre><p><em>Prepare the component to be added to the template.</em></p>\n<p><strong>html:string</strong><br>The components html that you want to load.</p>\n<p><strong>placeholder:string</strong><br>A html selector that should be the parent of the html you want to add. The contents of the placeholder will be removed before adding the new html.</p>\n<hr>\n<h3 id="renderer-html-">renderer.html()</h3>\n<pre><code>renderer.html()<span class="hljs-comment">;</span>\n</code></pre><p><em>Replaces all the components that are added with <code>renderer.render</code> to the template at once. This way templates will only be added once even if they have been declared for replacement multiple times. </em></p>\n\n    ',"article");next()}},{}],21:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n        <h1 id="lg-client-router-reference">lg-client-router reference</h1>\n<p>A Lagoon road extension that gives you route functionality on the client.</p>\n<table>\n<thead>\n<tr>\n<th>Information</th>\n<th>-</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Code coverage</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Repo link</td>\n<td><a href="https://github.com/lagoon-road/lr-client-router">lr-client-router</a></td>\n</tr>\n<tr>\n<td>Dependencies</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Size (Browserify, Babel, Uglify and Gzip)</td>\n<td>639 bytes</td>\n</tr>\n<tr>\n<td>Version</td>\n<td>1.0.0</td>\n</tr>\n<tr>\n<td>License</td>\n<td>MIT</td>\n</tr>\n<tr>\n<td>Usage</td>\n<td><a href="https://www.lagoonroad.com/guide">lagoonroad.com/guide</a></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id="adding-the-extension-to-lagoon-road">Adding the extension to lagoon road</h3>\n<pre><code><span class="hljs-attribute">const router</span>   = require(<span class="hljs-string">\'lg-client-router\'</span>);\n<span class="hljs-attribute">const core</span>     = require(<span class="hljs-string">\'lr-core\'</span>);\n<span class="hljs-attribute">const road</span>     = core(<span class="hljs-string">\'client\'</span>)\n  .extension(<span class="hljs-string">\'router\'</span>, router, true);\n</code></pre><hr>\n<h3 id="router-redirect-path-">router.redirect(path)</h3>\n<pre><code><span class="hljs-selector-tag">router</span><span class="hljs-selector-class">.redirect</span>(<span class="hljs-string">\'/some-page\'</span>);\n</code></pre><p><strong>path:string</strong><br>The path to where you want to redirect, this will trigger an update event on the road.</p>\n<hr>\n\n    ',"article");next()}},{}],22:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n        <h1 id="lg-core-reference">lg-core reference</h1>\n<p>The <em>lr-core</em> package is the only mandatory package for Lagoon road. This package connects everything together, regardless of environment.</p>\n<table>\n<thead>\n<tr>\n<th>Information</th>\n<th>-</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Code coverage</td>\n<td><a href="https://coveralls.io/github/lagoon-road/lr-core?branch=master"><img src="https://coveralls.io/repos/github/lagoon-road/lr-core/badge.svg?branch=master" alt="Coverage Status"></a></td>\n</tr>\n<tr>\n<td>Repo link</td>\n<td><a href="https://github.com/lagoon-road/lr-core">lr-core</a></td>\n</tr>\n<tr>\n<td>Dependencies</td>\n<td><a href="https://github.com/philbooth/check-types.js">check-types</a></td>\n</tr>\n<tr>\n<td>Size (Browserify, Babel, Uglify and Gzip)</td>\n<td>5.1KB</td>\n</tr>\n<tr>\n<td>Version</td>\n<td>1.0.0</td>\n</tr>\n<tr>\n<td>License</td>\n<td>MIT</td>\n</tr>\n<tr>\n<td>Usage</td>\n<td><a href="https://www.lagoonroad.com/guide">lagoonroad.com/guide</a></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id="core-environmentid-options-">core(environmentId, [options])</h3>\n<pre><code><span class="hljs-attribute">const core</span> = require(<span class="hljs-string">\'lr-core\'</span>);\n<span class="hljs-attribute">const road</span> = core(<span class="hljs-string">\'webserver\'</span>);\n</code></pre><p><strong>environmentId:string</strong><br>The primary environment id for the road, this is the executing environment that will be used when an update cycle is fired.</p>\n<p><strong>[options.parser:object]</strong><br>The parser to use when handling the <em>matchValue</em>. Read more about parsers in the <a href="https://lagoonroad.com/guide#parsers">guide</a>.</p>\n<p><strong>[options.resetAfterCycle:boolean]</strong><br>By default the relay object gets cleared after an update cycle of the road, sometimes, mainly on the client, you want to keep the relay populated even if an update cycle has ran. To do so, you can set this boolean to  <em>false</em></p>\n<hr>\n<h3 id="road-parser-parser-">road.parser(parser)</h3>\n<pre><code>const <span class="hljs-keyword">parser</span> = require(<span class="hljs-symbol">\'lr</span>-url-parser\')<span class="hljs-literal">()</span>;\nroad.<span class="hljs-keyword">parser</span>(<span class="hljs-keyword">parser</span>);\n</code></pre><p><strong>parser:object</strong><br>The parser that you want to use to parse an incoming matchValue. It expects two functions in the object, <code>add</code> and <code>parse</code>. Read more about parsers in the <a href="/guide/how-to-write-a-parser">guide</a></p>\n<hr>\n<h3 id="road-extension-extensionid-extension-isupdater-">road.extension(extensionId, extension, [isUpdater])</h3>\n<pre><code>road.extension(<span class="hljs-string">\'router\'</span>, router, <span class="hljs-literal">true</span>);\n</code></pre><p><strong>extensionId:string</strong><br>A unique id to identify the extension.</p>\n<p><strong>extension:*</strong><br>The actual extension, this can be any type of code that you want to use</p>\n<p><strong>[isUpdater:boolean = false]</strong><br>Tell the core if on initialization the extension needs to be executed. This is typically for extensions that use update events to trigger updates to the road. Read more about <a href="https://lagoonroad.com/guide#extensions">extensions</a> in the guide.</p>\n<blockquote>\n<p>Extensions can be used in middleware via the relay object.</p>\n<pre><code><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">next</span>, relay)</span> =&gt;</span> {\n  console.log(relay.extensions.extensionName);\n  <span class="hljs-built_in">next</span>();\n}\n</code></pre></blockquote>\n<hr>\n<h3 id="road-middleware-middleware-traditional-">road.middleware(middleware, [...traditional])</h3>\n<pre><code>road.middleware({ bodyParser, response }, <span class="hljs-string">\'bodyParser\'</span>, <span class="hljs-string">\'response\'</span>);\n</code></pre><p><strong>middleware:object</strong><br>An object with all the middleware you want to use. This is a single depth object so don&#39;t use any nested structures.</p>\n<blockquote>\n<p>Middleware methods can be called multiple times, the middleware will all be added to a single object within the core. Therefore you need to supply unique ids/keys.\nIf you have a multitude of middleware functions that you  want to use it might be handy to use a dot notation to  group your middleware.</p>\n<pre><code>road.middleware({\n  <span class="hljs-string">\'templating.component.navigation\'</span> : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'...\'</span>),  \n  <span class="hljs-string">\'templating.component.home\'</span>       : <span class="hljs-built_in">require</span>(<span class="hljs-string">\'...\'</span>),  \n});\n</code></pre><p>Read more about how to define and use middleware in the <a href="https://lagoonroad.com/guide#middleware">guide</a>.</p>\n</blockquote>\n<p><strong>traditional:string</strong>\nThe middleware id of the middleware that you want to run in traditional mode. The relay object wil <em>not</em> be passed in. The traditional function signature looks as follows:</p>\n<pre><code>// traditional, <span class="hljs-built_in">error</span> is optional\n(request, response, <span class="hljs-built_in">next</span>, <span class="hljs-built_in">error</span>) =&gt; {}\n</code></pre><hr>\n<h3 id="road-where-environmentid-environmentid-">road.where(environmentId, [...environmentId])</h3>\n<pre><code>road.<span class="hljs-keyword">where</span>(<span class="hljs-string">\'webserver\'</span>, <span class="hljs-string">\'client\'</span>);\n</code></pre><p><em>When assigning middleware to the road you might want to switch the environment they need to be assigned to. You can do that by using the <code>where</code> method.</em></p>\n<p><strong>environmentId</strong><br>The where method expects at least one argument, which should be a string. This is an environment id to which all the following middleware will be assigned. If you want to assign middleware to multiple environments you can just specify several ids like in the example above.</p>\n<hr>\n<h3 id="road-run-matchvalue-middlewareid-matchvalue-">road.run(matchValue, middlewareId, [matchValue])</h3>\n<pre><code>road.<span class="hljs-built_in">run</span>(<span class="hljs-string">\'*\'</span>, <span class="hljs-string">\'log\'</span>);\n</code></pre><p><strong>matchValue:string</strong><br>A match value in most webapps can be thought of as an url path, but it is not limited to paths only. Frankly it can be any string you can think of, even a JSON string to match on JSON content. Or in an even more exotic example you can match Raspberry pie sensor outputs via an extension to string values and let that trigger middleware. You can use the <code>*</code> as a wildcard to match on all match values that might come in.</p>\n<p><strong>middlewareId:string</strong><br>Identifier you added by using the <code>middleware</code> method. It needs to be a string and should match to a middleware function, otherwise it will throw.</p>\n<p><strong>[updateType:string]</strong><br>The update type is an extra layer for matching middleware, if we use a http protocol to update the road, this will be the method for the request. By default it wil be <code>GET</code> because it is the most common, but it can be overwritten to be something else. Again you are not limited to http methods, it fully depends on what an extension sends out via an update event.</p>\n<hr>\n<h3 id="road-error-middlewareid-updatetype-">road.error(middlewareId, [updateType])</h3>\n<pre><code>road.<span class="hljs-keyword">error</span>(\'<span class="hljs-built_in">log</span>\')\n</code></pre><p><em>Whenever the stack of middleware that is updated throws an error, it will be redirected to error middleware. You can use it to render alternative content or log the errors. The <code>relay</code> object will have a new property <code>relay.error</code> with the error message.</em></p>\n<p><strong>middlewareId:string</strong><br>Identifier you added by using the <code>middleware</code> method. It needs to be a string and should match to a middleware function, otherwise it will throw.</p>\n<p><strong>[updateType:string]</strong><br>The update type is an extra layer for matching middleware, if we use a http protocol to update the road, this will be the method for the request. By default it wil be <code>GET</code> because it is the most common, but it can be overwritten to be something else. Again you are not limited to http methods, it fully depends on what an extension sends out via an update event.</p>\n<hr>\n<h3 id="road-nomatch-middlewareid-updatetype-">road.noMatch(middlewareId, [updateType])</h3>\n<pre><code><span class="hljs-selector-tag">road</span><span class="hljs-selector-class">.noMatch</span>(<span class="hljs-string">\'log\'</span>);\n</code></pre><p><em>When no middleware could be found for a current combination of <code>matchValue</code> and <code>updateType</code>, the <code>noMatch</code> middleware will be called, this is handy if you want to return a 404 page or something similar.</em></p>\n<p><strong>middlewareId:string</strong><br>Identifier you added by using the <code>middleware</code> method. It needs to be a string and should match to a middleware function, otherwise it will throw.</p>\n<p><strong>[updateType:string]</strong><br>The update type is an extra layer for matching middleware, if we use a http protocol to update the road, this will be the method for the request. By default it wil be <code>GET</code> because it is the most common, but it can be overwritten to be something else. Again you are not limited to http methods, it fully depends on what an extension sends out via an update event.</p>\n<hr>\n<h3 id="road-done-middlewareid-updatetype-">road.done(middlewareId, [updateType])</h3>\n<pre><code><span class="hljs-selector-tag">road</span><span class="hljs-selector-class">.done</span>(<span class="hljs-string">\'response\'</span>, <span class="hljs-string">\'post\'</span>);\n</code></pre><p><em>The <code>done</code> method is called as the last method in the stack, it is typically used to render output (html or json) to a client</em></p>\n<p><strong>middlewareId:string</strong><br>Identifier you added by using the <code>middleware</code> method. It needs to be a string and should match to a middleware function, otherwise it will throw.</p>\n<p><strong>[updateType:string]</strong><br>The update type is an extra layer for matching middleware, if we use a http protocol to update the road, this will be the method for the request. By default it wil be <code>GET</code> because it is the most common, but it can be overwritten to be something else. Again you are not limited to http methods, it fully depends on what an extension sends out via an update event.</p>\n<hr>\n<h3 id="road-update-options-object-parameters-">road.update(options:object, [...parameters])</h3>\n<pre><code><span class="hljs-selector-tag">road</span><span class="hljs-selector-class">.update</span>({ <span class="hljs-attribute">matchValue </span>: <span class="hljs-string">\'/somepath\'</span>, updateType : <span class="hljs-string">\'post\'</span> }, <span class="hljs-selector-tag">parameterOne</span>, <span class="hljs-selector-tag">parameterTwo</span>);\n</code></pre><p><em>Manually trigger an upadte cycle to the road by calling the <code>update</code> method.</em></p>\n<p><strong>options.matchValue:string</strong><br>A match value in most webapps can be thought of as an url path, but it is not limited to paths only. Frankly it can be any string you can think of, even a JSON string to match on JSON content. Or in an even more exotic example you can match Raspberry pie sensor outputs via an extension to string values and let that trigger middleware. You can use the <code>*</code> as a wildcard to match on all match values that might come in.</p>\n<p><strong>options.updateType:string</strong><br>The update type is an extra layer for matching middleware, if we use a http protocol to update the road, this will be the method for the request. By default it wil be <code>GET</code> because it is the most common, but it can be overwritten to be something else. Again you are not limited to http methods, it fully depends on what an extension sends out via an update event.</p>\n<p><strong>parameters:*</strong><br>Each update can be have custom parameters that will be available as middleware arguments. This could be for example the <code>request</code> and <code>response</code> object on a router update.</p>\n<blockquote>\n<p>Read more about parameters in the <a href="https://lagoonroad.com/guide#middleware">middleware</a> section.\nEvery time a update method is called the middleware that matches will be added to the stack of middleware that needs to be executed. So when calling this on the server you might send out a response and afterwards more middleware will be called. Therefore use it on the client mainly to initialize events. Make sure you fully understand the middelware stack before start using the update function.</p>\n</blockquote>\n<h2 id="relay-object">Relay object</h2>\n<p>The relay object is passed from middleware function to middleware function. There are a couple of properties and methods in this object that cannot be overwritten. If you will try to do so, Lagoon road will throw an error to warn you of naming conflicts.</p>\n<h3 id="relay-extensions-object">relay.extensions:object</h3>\n<p>An Object that has all the registered extensions in it. This way all extensions will not get scattered all over the object.</p>\n<h3 id="relay-update-options-object-function">relay.update(options:object):function</h3>\n<p>Trigger a manual update event on the road, you are expected to pass an options object in, the options has one mandatory property which is <code>matchValue</code>. <code>matchvalue</code> needs to be a string value. This will be used to match in <code>run</code> hooks.</p>\n<p>The second options propery is optional, it is the <code>updateType</code> property. The default value is <code>get</code>, but can be set to anything. When triggering an update for a HTTP request, it will typically be the method type.</p>\n<h3 id="relay-exit-function">relay.exit():function</h3>\n<p>When you want to prematurely finish the update cycle you have to call the <code>exit()</code> function. You want to use this when you want to send a <code>response.end</code> before the <code>done</code> hook. This function should be used rarely, read more about it in the <a href="/guide/stack">stack</a> and <a href="/guide/serving-static-content">serving static content</a> guides.</p>\n\n    ',"article");
next()}},{}],23:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n        <h1 id="lg-server-renderer-reference">lg-server-renderer reference</h1>\n<p>Server side renderer for lagoon road.</p>\n<table>\n<thead>\n<tr>\n<th>Information</th>\n<th>-</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Code coverage</td>\n<td><a href="https://coveralls.io/github/lagoon-road/lr-server-renderer?branch=master"><img src="https://coveralls.io/repos/github/lagoon-road/lr-server-renderer/badge.svg?branch=master" alt="Coverage Status"></a></td>\n</tr>\n<tr>\n<td>Repo link</td>\n<td><a href="https://github.com/lagoon-road/lr-server-renderer">lr-core</a></td>\n</tr>\n<tr>\n<td>Dependencies</td>\n<td><a href="https://github.com/cheeriojs/cheerio">cheerio</a></td>\n</tr>\n<tr>\n<td>Size (ex. dependencies)</td>\n<td>612 bytes</td>\n</tr>\n<tr>\n<td>Version</td>\n<td>1.0.0</td>\n</tr>\n<tr>\n<td>License</td>\n<td>MIT</td>\n</tr>\n<tr>\n<td>Usage</td>\n<td><a href="https://www.lagoonroad.com/guide">lagoonroad.com/guide</a></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id="renderer-template-html-">renderer.template(html)</h3>\n<pre><code>renderer.template(<span class="hljs-comment">\'<span class="hljs-doctag">&lt;html&gt;</span>...<span class="hljs-doctag">&lt;/html&gt;</span>\');</span>\n</code></pre><p><em>Method sets the template for the output, all components will be added to this template</em></p>\n<p><strong>html:string</strong><br>The template you want to use for the components and state that you might want to add.</p>\n<hr>\n<h3 id="renderer-render-html-placeholder-">renderer.render(html, placeholder)</h3>\n<pre><code><span class="hljs-keyword">renderer</span>.<span class="hljs-keyword">render</span>(<span class="hljs-string">\'&lt;section&gt;...&lt;/section&gt;\'</span>, <span class="hljs-string">\'.placeholderName\'</span>);\n</code></pre><p><em>Adds a component to the template.</em></p>\n<p><strong>html:string</strong><br>The components html that you want to load.</p>\n<p><strong>placeholder:string</strong><br>A html selector that should be the parent of the html you want to add. The contents of the placeholder will be removed before adding the new html.</p>\n<hr>\n<h3 id="renderer-state-state-">renderer.state(state)</h3>\n<pre><code><span class="hljs-selector-tag">renderer</span><span class="hljs-selector-class">.state</span>({ <span class="hljs-attribute">data </span>: [...], otherProperties : true });\n</code></pre><p><em>Add data to a script tag that you can access on the client again. This prevents loading the same data. The data will be available by accessing <code>window.__state__</code> as json.</em></p>\n<p><strong>state:object</strong><br>An object that has been loaded on the server that you want to transfer to the client.</p>\n<hr>\n<h3 id="renderer-html-">renderer.html()</h3>\n<pre><code>renderer.html()<span class="hljs-comment">;</span>\n</code></pre><p><em>Get the final output of the template and components that you have created, this data can be send back as the response to the client.</em></p>\n\n    ',"article");next()}},{}],24:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n        <h1 id="lg-server-router-reference">lg-server-router reference</h1>\n<p>A Lagoon road extension that gives you route functionality on the server.</p>\n<table>\n<thead>\n<tr>\n<th>Information</th>\n<th>-</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Code coverage</td>\n<td><a href="https://coveralls.io/github/lagoon-road/lr-server-router?branch=master"><img src="https://coveralls.io/repos/github/lagoon-road/lr-server-router/badge.svg?branch=master" alt="Coverage Status"></a></td>\n</tr>\n<tr>\n<td>Repo link</td>\n<td><a href="https://github.com/lagoon-road/lr-server-router">lr-server-router</a></td>\n</tr>\n<tr>\n<td>Dependencies</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Size</td>\n<td>336 bytes</td>\n</tr>\n<tr>\n<td>Version</td>\n<td>1.0.0</td>\n</tr>\n<tr>\n<td>License</td>\n<td>MIT</td>\n</tr>\n<tr>\n<td>Usage</td>\n<td><a href="https://www.lagoonroad.com/guide">lagoonroad.com/guide</a></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id="function-initialization">Function initialization</h3>\n<p>This package doesn&#39;t have any exposed methods, it does however needs a single argument on creation.</p>\n<pre><code><span class="hljs-attribute">const protocol</span> = require(<span class="hljs-string">\'http\'</span>);\n<span class="hljs-attribute">const server</span>   = protocol.createServer();\n<span class="hljs-attribute">const router</span>   = require(<span class="hljs-string">\'lg-server-router\'</span>)(server);\n<span class="hljs-attribute">const core</span>     = require(<span class="hljs-string">\'lr-core\'</span>);\n<span class="hljs-attribute">const road</span>     = core(<span class="hljs-string">\'webserver\'</span>)\n  .extension(<span class="hljs-string">\'router\'</span>, router, true);\n</code></pre><hr>\n\n    ',"article");next()}},{}],25:[function(require,module,exports){"use strict";module.exports=function(next,relay){relay.extensions.renderer.render('\n        <p><a href="https://coveralls.io/github/lagoon-road/lr-url-parser?branch=master"><img src="https://coveralls.io/repos/github/lagoon-road/lr-url-parser/badge.svg?branch=master" alt="Coverage Status"></a></p>\n<h1 id="lr-url-parser">lr-url-parser</h1>\n<p>Parser that can take placeholders from urls and match them with real urls</p>\n\n    ',"article");next()}},{}],26:[function(require,module,exports){"use strict";module.exports=function(next,relay){var logo=document.querySelector(".logo");var content=document.querySelector(".content");if(window.location.pathname==="/"){logo.classList.remove("compact");content.classList.remove("compact")}else{logo.classList.add("compact");content.classList.add("compact")}function resize(){document.querySelector(".animations").style.height=0;document.querySelector(".animations").style.height=document.querySelector("body").scrollHeight+"px"}window.resize=function(){resize()};resize();next()}},{}]},{},[5]);
